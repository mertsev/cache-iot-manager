<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2016.2 (Build 728U)" ts="2016-12-07 12:22:08">
<Class name="DeepSee.SensorData">
<Description>
</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%DeepSee.CubeDefinition</Super>
<TimeChanged>64125,37083.985158</TimeChanged>
<TimeCreated>64125,30017.582488</TimeCreated>
<DependsOn>Net.MQTT.Storage</DependsOn>

<XData name="Cube">
<Description>
Cube definition from Architect.</Description>
<XMLNamespace>http://www.intersystems.com/deepsee</XMLNamespace>
<Data><![CDATA[
<cube xmlns="http://www.intersystems.com/deepsee" name="SensorData" displayName="Sensor Data" disabled="false" abstract="false" sourceClass="Net.MQTT.Storage" countMeasureName="%COUNT" bucketSize="8" bitmapChunkInMemory="false" precompute="0" disableListingGroups="false">
  <dimension name="Devices" disabled="false" hasAll="false" allCaption="All DeviceID" allDisplayName="DeviceID" type="data" calendar="gregorian" iKnowType="entity" hidden="false" showHierarchies="default">
    <hierarchy name="H1" disabled="false" hidden="false">
      <level name="DeviceID" displayName="Device ID" disabled="false" sourceProperty="DeviceID" list="false" useDisplayValue="true" useAsFilter="true" hidden="false">
      </level>
    </hierarchy>
    <additionalDescription>undefined</additionalDescription>
  </dimension>
  <dimension name="Sensors" disabled="false" hasAll="false" allCaption="All SensorType" allDisplayName="SensorType" type="data" calendar="gregorian" iKnowType="entity" hidden="false" showHierarchies="default">
    <hierarchy name="H1" disabled="false" hidden="false">
      <level name="SensorType" displayName="Sensor Type" disabled="false" sourceProperty="SensorType" list="false" useDisplayValue="true" useAsFilter="true" hidden="false">
      </level>
    </hierarchy>
    <additionalDescription>undefined</additionalDescription>
  </dimension>
  <dimension name="SentAt" displayName="Sent At" disabled="false" hasAll="false" allCaption="All CreatedAt" allDisplayName="CreatedAt" sourceProperty="CreatedAt" type="data" calendar="gregorian" iKnowType="entity" hidden="false" showHierarchies="default">
    <hierarchy name="H1" disabled="false" hidden="false">
      <level name="SentAtDate" displayName="Sent at - Date" disabled="false" sourceExpression="$Extract(%source.CreatedAt, 1, 10)" list="false" useDisplayValue="true" useAsFilter="true" hidden="false">
      </level>
      <level name="SentAtHour" displayName="Sent at - Hour" disabled="false" sourceExpression="$Extract(%source.CreatedAt, 1, 13)" timeFunction="HourNumber" list="false" useDisplayValue="true" useAsFilter="true" hidden="false">
        <property name="SentAtHourP" displayName="Sent at - Hour" disabled="false" sourceExpression="$Extract(%source.CreatedAt, 12, 13)" hidden="false" isName="true" isDescription="false" isReference="false" useDisplayValue="false">
          <additionalDescription>undefined</additionalDescription>
        </property>
      </level>
      <level name="SentAtMinute" displayName="Sent at - Minute" disabled="false" sourceExpression="$Extract(%source.CreatedAt, 1, 16)" timeFunction="MinuteNumber" list="false" useDisplayValue="true" useAsFilter="true" hidden="false">
        <property name="SentAtMinuteP" displayName="Sent at - Minute" disabled="false" sourceExpression="$Extract(%source.CreatedAt, 12, 16)" hidden="false" isName="true" isDescription="false" isReference="false" useDisplayValue="false">
          <additionalDescription>undefined</additionalDescription>
        </property>
      </level>
      <level name="SentAtSecond" displayName="Sent at - Second" disabled="false" sourceExpression="$Extract(%source.CreatedAt, 1, 19)" list="false" useDisplayValue="true" useAsFilter="true" hidden="false">
        <property name="SentAtSecondP" displayName="Sent at - Second" disabled="false" sourceExpression="$Extract(%source.CreatedAt, 12, 19)" hidden="false" isName="true" isDescription="false" isReference="false" useDisplayValue="false">
          <additionalDescription>undefined</additionalDescription>
        </property>
      </level>
    </hierarchy>
    <additionalDescription>undefined</additionalDescription>
  </dimension>
  <measure name="Value" displayName="Sensor Value" disabled="false" sourceProperty="Value1" aggregate="AVG" type="number" hidden="false" searchable="false">
  </measure>
</cube>
]]></Data>
</XData>

<Parameter name="DOMAIN">
</Parameter>
</Class>


<Project name="MQTT" LastModified="2016-12-07 12:22:08.116069">
  <Items>
    <ProjectItem name="DeepSee.SensorData" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.Agent" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.Aux.MessageCounter" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.Aux.MessageStatus" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.Aux.Subscription" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.Aux.SubscriptionTopic" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.Aux.TaskList" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.Auxiliary.MessageCounter" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.Auxiliary.MessageStatus" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.Auxiliary.Subscription" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.Auxiliary.SubscriptionTopic" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.Auxiliary.TaskList" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.BMClient" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.Client" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.Delayer" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.Message" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.MessageHandler" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.MessageStore" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.Parameters" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.Storage" type="CLS"></ProjectItem>
    <ProjectItem name="REST.Broker" type="CLS"></ProjectItem>
    <ProjectItem name="REST.Callback" type="CLS"></ProjectItem>
    <ProjectItem name="REST.JSON" type="CLS"></ProjectItem>
  </Items>
</Project>


<Class name="Net.MQTT.Agent">
<Description><![CDATA[
The MQTT Agent is always started by a <class>Net.MQTT.Client</class> in the background to manage the real communication with the broker.
<p>The agent inherits its settings from the Client, which started it and it is responsible for:<ul>
<li>Building the TCP connection to the broker.</li>
<li>Executing the tasks created by the Client (and the Agent itself) based on the <class>Net.MQTT.Auxiliary.TaskList</class> records.
 E.g.: sending various messages to the broker.</li>
<li>Keeping the connection alive by sending PING requests to the broker, when no other messages has been sent for a certain amount of time.</li>
<li>Listening for incoming messages from the broker and triggering appropriate actions based on the message type.</li>
</ul></p>]]></Description>
<Super>Net.MQTT.Client</Super>
<TimeChanged>64152,49723.657073</TimeChanged>
<TimeCreated>64051,64922.792357</TimeCreated>

<Property name="connected">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="device">
<Type>%String</Type>
</Property>

<Property name="saveIODev">
<Type>%String</Type>
</Property>

<Property name="transTable">
<Type>%String</Type>
<InitialExpression>##class(%IO.I.TranslationDevice).GetCharEncodingTable("UTF-8")</InitialExpression>
</Property>

<Property name="lastMessage">
<Type>%TimeStamp</Type>
<InitialExpression>$ZDateTime($ZTimeStamp, 3, 1)</InitialExpression>
</Property>

<Property name="lastPing">
<Type>%TimeStamp</Type>
</Property>

<Property name="fatalError">
<Description><![CDATA[
If connection error is assumed, an automatic re-connect attempt is done by the Agent.
In that period this property is set to <var>-1</var>.
<p>If automatic re-connect is not possible, <property>fatalError</property> is set to <var>1</var>,
and the Agent stops itself.</p>]]></Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="MAXVAL" value="1"/>
<Parameter name="MINVAL" value="-1"/>
</Property>

<Property name="username">
<Type>%String</Type>
<Transient>1</Transient>
</Property>

<Property name="password">
<Type>%String</Type>
<Transient>1</Transient>
</Property>

<Method name="StartListening">
<Description><![CDATA[
This method is called directly (as a background job) by the <class>Net.MQTT.Client</class> to start the Agent.
<p><var>pInitialState</var> is the XML serialized content of the calling Client object, from which the agent can populate its own properties.</p>
<p><var>pUsername</var> and <var>pPassword</var> are the optional credentials to be sent to the broker on connecting.</p>
<p>The Agent builds the TCP connection to the broker, sends a <b><var>CONNECT</var></b> message and then starts to communicate with the broker.</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pInitialState:%String,pUsername:%String="",pPassword:%String=""</FormalSpec>
<Implementation><![CDATA[
	Set ret = ""
	Set reader = ##class(%XML.Reader).%New()
	Do reader.Correlate("root", ..%ClassName(1))
	Set tSC = reader.OpenString(pInitialState)
	If $$$ISOK(tSC) && reader.Next(.agent) {
		// It's necessary to strore username and password in memory for automatic reconnect feature
		Set agent.username = pUsername
		Set agent.password = pPassword
		Set tSC = agent.DoCONNECT(agent.username, agent.password)
		If $$$ISOK(tSC) {
			Do agent.Listen()
		}
		Else {
			Set ret = $System.Status.GetErrorText(tSC)
		}
	}
	Else {
		Set ret = "MQTT Agent cannot start (missing initial state)"
	}
]]></Implementation>
</Method>

<Method name="Listen">
<Description><![CDATA[
The main function of the Agent. Unless a fatal error happens, it runs in an endless loop, doing onw of the followin things in every loop:<ul>
<li>If a pending <class>Net.MQTT.Auxiliary.TaskList</class> object can be found for the Agent's unique <property>connectionId</property>,
 it starts to execute the corresponding task, then signals the initiator of the task via the <class>%SYSTEM.Event</class> API.</li>
<li>If no response has arrived from the broker for the last PING request within the <property>KeepAliveInterval</property>
 it treats the connection to the broker broken and stops.</li>
<li>If no other messages has been sent to the broker for a certain amount of time (~ 80% of the ) <property>KeepAliveInterval</property>,
 it sends a PING request to keep the connection alive.</li>
<li>Listens for incoming messages.</li>
</ul>]]></Description>
<Internal>1</Internal>
<Private>1</Private>
<Implementation><![CDATA[
	If ..SSLConfig = "" {
		Use ..device
	}
	Else {
		Use ..device:(:::::::/SSL=..SSLConfig)
	}
	$$$MQTTTraceINF("Agent for " _ ..ClientId _ " to <" _ ..Host _ ":" _ ..Port _ "> starts listening")
	Do SetIO^%NLS("RAW")
	While 1 {
		If ..fatalError > 0 {
			Quit
		}
		
		TRY {
			Set tSC = ##class(Net.MQTT.Auxiliary.TaskList).AcquireNext(..connectionId, .taskId, .contextId, .action)
			If $$$ISOK(tSC) {
				If taskId '= "" {
					If $$$MQTTTraceDebug {
						$$$MQTTTraceDEB("Agent for " _ ..ClientId _ " to <" _ ..Host _ ":" _ ..Port _ "> processes task (" _taskId _ ")")
					}
					Else {
						$$$MQTTTraceINF("Agent for " _ ..ClientId _ " to <" _ ..Host _ ":" _ ..Port _ "> processes '" _ action _ "' action")
					}
					Set tSC = $METHOD($this, "Do" _ action, taskId, contextId)
					Set tSC = ##class(Net.MQTT.Auxiliary.TaskList).SignalTask(..connectionId, taskId, tSC, $$$MQTTTraceDebug)
				}
				ElseIf (..lastPing '= "") && ($System.SQL.DATEDIFF("s", ..lastPing, $ZDateTime($ZTimeStamp, 3, 1)) > ..KeepAliveInterval) {
					$$$MQTTTraceERR("PINGRESP message has not arrived from <" _ ..Host _ ":" _ ..Port _ "> within the timeout interval")
					Set ..fatalError = 1
				}
				ElseIf $System.SQL.DATEDIFF("s", ..lastMessage, $ZDateTime($ZTimeStamp, 3, 1)) > (..KeepAliveInterval * .8) {
					$$$MQTTTraceINF("Agent for " _ ..ClientId _ " to <" _ ..Host _ ":" _ ..Port _ "> sends ping")
					Set tSC = ..SendPINGREQ()
					If $$$ISERR(tSC) {
						$$$MQTTTraceERR("PINGREQ message cannot be sent to <" _ ..Host _ ":" _ ..Port _ ">")
						Set ..fatalError = 1
					}
				}
				Else {
					Set tSC = ..RecvMessage()
				}
			}
		}
		CATCH ex {
			Set tSC = ex.AsStatus()
		}
		
		If $$$ISERR(tSC) {
			$$$MQTTTraceERR($System.Status.GetErrorText(tSC))
		}
	}
	
	Do ..CloseDev()
	Use ..saveIODev
	
	Quit
]]></Implementation>
</Method>

<Method name="RecvMessage">
<Description><![CDATA[
Listens for incoming messages.
<p>First takes a 1 byte MQTT Header. The takes the following 1 to 4 bytes to define the remaining length of the message.
 Finally reads the remaining part of the message and triggers appropriate action based on the message type (extracted from the Header).</p>]]></Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Set tSC = $$$OK
 TRY {	
	Read header#1:0 Set timeout = ('$Test)
	If 'timeout {
		$$$MQTTTraceIN("Header", header, $$$MQTTTraceDebug)
		Set type	= ..GetMessageType(header)
		Set typeT	= $$$MQTTMsgType(type)
		Set dup		= ..IsDuplicate(header)
		Set qos		= ..GetQoSLevel(header)
		Set retain	= ..IsRetain(header)
		
		Set multi = 1, length = 0, pos = 2, rl = ""
		For i = 1: 1: 4 {
			Read next#1:..ReadTimeout Set timeout = ('$Test)
			If timeout {
				Set tSC = $$$ERROR($$$GeneralError, "Invalid " _ typeT _ " message has arrived from <" _ ..Host _ ":" _ ..Port _ "> (missing Remaining Length)")
				Quit
			}
			Set rl = rl _ next
			Set next = $Ascii(next)
			Set length = length + ((next # 128) * multi)
			If next < 128 { Quit }
			Set multi = multi * 128
		}
		
		Set content = ""
		$$$MQTTTraceIN("Length", rl, $$$MQTTTraceDebug)
		If $$$ISOK(tSC) && (length > 0) {
			Read content#length:..ReadTimeout Set timeout = ('$Test)
			If timeout || ($Length(content) '= length) {
				Set tSC = $$$ERROR($$$GeneralError, "Invalid " _ typeT _ " message has arrived from <" _ ..Host _ ":" _ ..Port _ "> (missing content)")
			}
		}
		If $$$ISOK(tSC) {
			$$$MQTTTraceIN(typeT, header _ rl _ content, $$$MQTTTraceInfo)
		}
		Set tSC = $METHOD($this, "Recv" _ typeT, dup, qos, retain, content)
	}
 }
 CATCH ex {
	If ex.%IsA("%Exception.SystemException") && (ex.Name = "<READ>") {
		$$$MQTTTraceWRN("MQTT broker probably closed TCP connection to <" _ ..Host _ ":" _ ..Port _ "> (READ error)")
		// Try reconnect
		Set sc = $$$OK
		If ('..fatalError) {
			Set ..fatalError = -1
			Set sc = ..DoCONNECT(..username, ..password)
		}
		If $$$ISERR(sc) {
			$$$MQTTTraceERR("Agent couldn't re-connect automatically to <" _ ..Host _ ":" _ ..Port _ ">")
			Set ..fatalError = 1
		}
	}
	Set tSC = ex.AsStatus() 
 } 
 Quit tSC
]]></Implementation>
</Method>

<Method name="DoCONNECT">
<Description><![CDATA[
Builds the TCP connection to the MQTT broker and sends the <b><var>CONNECT</var></b> message.]]></Description>
<Internal>1</Internal>
<FormalSpec>pUsername:%String="",pPassword:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	$$$MQTTTraceINF("Agent for " _ ..ClientId _ " to <" _ ..Host _ ":" _ ..Port _ "> is starting")
	
	Set ..saveIODev = $IO
	If ('..connected) {
		Set ..device = "|TCP|" _ ..Port _ "|" _ $P($Job, ":")
		Open ..device:(..Host:..Port::::::$Case(..SSLConfig, "": "", :"/SSL="_..SSLConfig)):..ConnectTimeout Set timeout=('$Test)
		
		If timeout {
			$$$MQTTTraceERR("Agent for " _ ..ClientId _ " to <" _ ..Host _ ":" _ ..Port _ "> failed to start TCP connection")
			Quit $$$ERROR($$$GeneralError, "TCP Connection to <" _ ..Host _ ":" _ ..Port _ "> has not succeeded within the timeout interval")
		}
		Else {
			$$$MQTTTraceINF("Agent for " _ ..ClientId _ " to <" _ ..Host _ ":" _ ..Port _ "> started TCP connection")
			Set ..connected = 1
		}
	}
	
	If ..SSLConfig = "" {
		Use ..device
	}
	Else {
		Use ..device:(:::::::/SSL=..SSLConfig)
	}
	Do SetIO^%NLS("RAW")
	Set tSC = ..SendCONNECT(pUsername, pPassword)
	If $$$ISERR(tSC) {
		Do ..CloseDev()
	} 
	Use ..saveIODev
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="DoDISCONNECT">
<Description><![CDATA[
Sends a <b><var>DISCONNECT</var></b> message to the MQTT broker and closes the TCP connection.]]></Description>
<Internal>1</Internal>
<FormalSpec>pTaskId:%String,pConnectionId:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..SendDISCONNECT()
	Do ..CloseDev()
	Use ..saveIODev
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="DoSUBSCRIBE">
<Description><![CDATA[
Sends a <b><var>SUBSCRIBE</var></b> message to the MQTT broker. 
<p>The <property>ContextId</property> of the corresponding <class>Net.MQTT.Auxiliary.TaskList</class> object is a Message Idenifier.
If it contains a colon, this is a repeated attempt, because no acknowledge has been received from the broker within the defined timout period.</p>
<p>The details of the <b><var>SUBSCRIBE</var></b> message must be stored in a <class>Net.MQTT.Auxiliary.Subscription</class> object.</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pTaskId:%String,pMessageId:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set dup = 0
	Set msgid = pMessageId
	If $Length(pMessageId, ":") > 1 {
		Set msgid = $Piece(pMessageId, ":", 1)
		Set dup = (''$Piece(pMessageId, ":", 2))
	}
	Set topics = ##class(Net.MQTT.Auxiliary.Subscription).GetTopicList(..ClientId, msgid, .tSC)
	Set:$$$ISOK(tSC) tSC = ..SendSUBSCRIBE(msgid, topics, dup)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="DoUNSUBSCRIBE">
<Description><![CDATA[
Sends a <b><var>UNSUBSCRIBE</var></b> message to the MQTT broker. 
<p>The <property>ContextId</property> of the corresponding <class>Net.MQTT.Auxiliary.TaskList</class> object is a Message Idenifier.
If it contains a colon, this is a repeated attempt, because no acknowledge has been received from the broker within the defined timout period.</p>
<p>The details of the <b><var>UNSUBSCRIBE</var></b> message must be stored in a <class>Net.MQTT.Auxiliary.Subscription</class> object.</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pTaskId:%String,pMessageId:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set dup = 0
	Set msgid = pMessageId
	If $Length(pMessageId, ":") > 1 {
		Set msgid = $Piece(pMessageId, ":", 1)
		Set dup = (''$Piece(pMessageId, ":", 2))
	}
	Set topics = ##class(Net.MQTT.Auxiliary.Subscription).GetTopicList(..ClientId, msgid, .tSC)
	Set:$$$ISOK(tSC) tSC = ..SendUNSUBSCRIBE(msgid, topics, dup)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="DoPUBLISH">
<Description><![CDATA[
Sends a <b><var>PUBLISH</var></b> message to the MQTT broker. 
<p>The <property>ContextId</property> of the corresponding <class>Net.MQTT.Auxiliary.TaskList</class> object is a <class>Net.MQTT.Auxiliary.MessageStore</class> object ID.
If it contains a colon, this is a repeated attempt, because no acknowledge has been received from the broker within the defined timout period.</p>
<p>The details of the <b><var>PUBLISH</var></b> message are stored in the referenced <class>Net.MQTT.Auxiliary.MessageStore</class> object.</p>
<p>On QoS levels &gt; 0 it also pushes the <class>Net.MQTT.Auxiliary.MessageStatus</class> to the next state 
 (either waiting for a <b><var>PUBACK</var></b> or <b><var>PUBREC</var></b> message).</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pTaskId:%String,pMessageStoreId:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set dup = 0
	Set msgid = pMessageStoreId
	If $Length(pMessageStoreId, ":") > 1 {
		Set msgid = $Piece(pMessageStoreId, ":", 1)
		Set dup = (''$Piece(pMessageStoreId, ":", 2))
	}
	Set message = ##class(Net.MQTT.MessageStore).%OpenId(msgid, -1, .tSC)
	Set:$$$ISOK(tSC) tSC = ..SendPUBLISH(message, dup)
	If $$$ISOK(tSC) {
		If message.QoSLevel = 1 {
			Set tSC = ##class(Net.MQTT.Auxiliary.MessageStatus).AcknowledgeMessageOut(..ClientId, message.MessageId)
		}
		ElseIf message.QoSLevel = 2 {
			Set tSC = ##class(Net.MQTT.Auxiliary.MessageStatus).ReceiveMessageOut(..ClientId, message.MessageId)
		}
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="DoPUBACK">
<Description><![CDATA[
Sends a <b><var>PUBACK</var></b> message to the MQTT broker for an incoming, QoS Level 1 message. 
<p>The <property>ContextId</property> of the corresponding <class>Net.MQTT.Auxiliary.TaskList</class> object is a Message Identifier.</p>
<p>This is the end of the message flow of the incoming message.</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pTaskId:%String,pMessageId:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..SendPUBACK(pMessageId)
	Set:$$$ISOK(tSC) tSC = ##class(Net.MQTT.Auxiliary.MessageStatus).DoneMessageIn(..ClientId, pMessageId)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="DoPUBREC">
<Description><![CDATA[
Sends a <b><var>PUBREC</var></b> message to the MQTT broker for an incoming, QoS Level 2 message. 
<p>The <property>ContextId</property> of the corresponding <class>Net.MQTT.Auxiliary.TaskList</class> object is a Message Identifier.</p>
<p>It also pushes the <class>Net.MQTT.Auxiliary.MessageStatus</class> to the next state (waiting for a <b><var>PUBREL</var></b> message).</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pTaskId:%String,pMessageId:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..SendPUBREC(pMessageId)
	Set:$$$ISOK(tSC) tSC = ##class(Net.MQTT.Auxiliary.MessageStatus).ReleaseMessageIn(..ClientId, pMessageId)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="DoPUBREL">
<Description><![CDATA[
Sends a <b><var>PUBREL</var></b> message to the MQTT broker for an outgoing, QoS Level 2 message. 
<p>The <property>ContextId</property> of the corresponding <class>Net.MQTT.Auxiliary.TaskList</class> object is a Message Identifier.
 If it contains a colon, this is a repeated attempt, because no acknowledge has been received for the original <b><var>PUBLISH</var></b> message
 from the broker within the defined timout period.</p>
<p>It also pushes the <class>Net.MQTT.Auxiliary.MessageStatus</class> to the next state (waiting for a <b><var>PUBCOMP</var></b> message).</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pTaskId:%String,pMessageId:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set dup = 0
	Set msgid = pMessageId
	If $Length(pMessageId, ":") > 1 {
		Set msgid = $Piece(pMessageId, ":", 1)
		Set dup = (''$Piece(pMessageId, ":", 2))
	}
	Set tSC = ..SendPUBREL(msgid, dup)
	Set:$$$ISOK(tSC) tSC = ##class(Net.MQTT.Auxiliary.MessageStatus).CompleteMessageOut(..ClientId, pMessageId)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="DoPUBCOMP">
<Description><![CDATA[
Sends a <b><var>PUBCOMP</var></b> message to the MQTT broker for an incoming, QoS Level 2 message. 
<p>The <property>ContextId</property> of the corresponding <class>Net.MQTT.Auxiliary.TaskList</class> object is a Message Identifier.</p>
<p>This is the end of the message flow of the incoming message.</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pTaskId:%String,pMessageId:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..SendPUBCOMP(pMessageId)
	Set:$$$ISOK(tSC) tSC = ##class(Net.MQTT.Auxiliary.MessageStatus).DoneMessageIn(..ClientId, pMessageId)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendCONNECT">
<Description><![CDATA[
Creates the variable header and payload of a <b><var>CONNECT</var></b> message and sends the package to the MQTT broker.]]></Description>
<Internal>1</Internal>
<FormalSpec>pUsername:%String="",pPassword:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If pUsername = "" {
		Set pPassword = ""
	}
	Set will = ($IsObject(..LastWill) && (..LastWill.Topic '= "") && (..LastWill.Content '= ""))
	
	Set varhdr = $Char($Select(..CleanSession: $$$MQTTCleanSession, 1: 0)
		+ $Select(will: $$$MQTTWillFlag, 1: 0)
		+ $Select((will && ..LastWill.QoSLevel = 1): $$$MQTTWillQoS1, (will && ..LastWill.QoSLevel = 2): $$$MQTTWillQoS2, 1: 0)
		+ $Select((will && ..LastWill.Retain): $$$MQTTWillRetain, 1: 0)
		+ $Select(pUsername '= "": $$$MQTTUsernameFlag, 1: 0)
		+ $Select(pPassword '= "": $$$MQTTPasswordFlag, 1: 0)
	)
	
	Set varhdr	= ..GetProtocolName() _ ..GetProtocolVersion() _ varhdr _ $$$MQTTEncodeNumber(..KeepAliveInterval)
	Set payload	= ..GetUTFString(..ClientId)
	If will {
		Set payload = payload _ ..GetUTFString(..LastWill.Topic) _ ..GetUTFString(..LastWill.Content)
	}
	If pUsername '= "" {
		Set payload = payload _ ..GetUTFString(pUsername)
		If pPassword '= "" {
			Set payload = payload _ ..GetUTFString(pPassword)
		}
	}
	
	Quit ..PackSendMsg(varhdr_payload, $$$MQTTCONNECT)
]]></Implementation>
</Method>

<Method name="SendDISCONNECT">
<Description><![CDATA[
Creates a <b><var>DISCONNECT</var></b> message and sends the package to the MQTT broker.]]></Description>
<Internal>1</Internal>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..PackSendMsg("", $$$MQTTDISCONNECT)
]]></Implementation>
</Method>

<Method name="SendPINGREQ">
<Description><![CDATA[
Creates a <b><var>PINGREQ</var></b> message and sends the package to the MQTT broker.]]></Description>
<Internal>1</Internal>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..PackSendMsg("", $$$MQTTPINGREQ)
	Set:$$$ISOK(tSC) ..lastPing = $ZDateTime($ZTimeStamp, 3, 1)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendSUBSCRIBE">
<Description><![CDATA[
Creates the variable header and payload of a <b><var>SUBSCRIBE</var></b> message and sends the package to the MQTT broker.]]></Description>
<Internal>1</Internal>
<FormalSpec>pMessageId:%Integer,pTopics:%ListOfObjects,pDup:%Boolean=0</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#dim topic As Net.MQTT.Message

	Set varhdr = $$$MQTTEncodeNumber(+pMessageId)
	
	Set payload = "", key = ""
	While 1 {
		Set topic = pTopics.GetNext(.key) Quit:(key = "")
		Set payload = payload _ ..GetUTFString(topic.Topic) _ $Char($Case(topic.QoSLevel, 2: $$$MQTTSubQoS2, 1: $$$MQTTSubQoS1, : 0))
	}
	
	Set tSC = ..PackSendMsg(varhdr_payload, $$$MQTTSUBSCRIBE, pDup, 1)
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendUNSUBSCRIBE">
<Description><![CDATA[
Creates the variable header and payload of an <b><var>UNSUBSCRIBE</var></b> message and sends the package to the MQTT broker.]]></Description>
<Internal>1</Internal>
<FormalSpec>pMessageId:%Integer,pTopics:%ListOfObjects,pDup:%Boolean=0</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#dim topic As Net.MQTT.Message

	Set varhdr = $$$MQTTEncodeNumber(+pMessageId)
	
	Set payload = "", key = ""
	While 1 {
		Set topic = pTopics.GetNext(.key) Quit:(key = "")
		Set payload = payload _ ..GetUTFString(topic.Topic)
	}
	
	Set tSC = ..PackSendMsg(varhdr_payload, $$$MQTTUNSUBSCRIBE, pDup, 1)
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendPUBLISH">
<Description><![CDATA[
Creates the variable header and payload of a <b><var>PUBLISH</var></b> message and sends the package to the MQTT broker.]]></Description>
<Internal>1</Internal>
<FormalSpec>pMessage:Net.MQTT.MessageStore,pDup:%Boolean=0</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set varhdr = ..GetUTFString(pMessage.Topic) _ $Select(pMessage.QoSLevel > 0: $$$MQTTEncodeNumber(+pMessage.MessageId), 1: "")
	
	Set tSC = ..PackSendMsg(varhdr_pMessage.Content, $$$MQTTPUBLISH, pDup, pMessage.QoSLevel, pMessage.Retain)
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendPUBACK">
<Description><![CDATA[
Creates the variable header of a <b><var>PUBACK</var></b> message and sends the package to the MQTT broker.]]></Description>
<Internal>1</Internal>
<FormalSpec>pMessageId:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set varhdr = $$$MQTTEncodeNumber(+pMessageId)
	
	Set tSC = ..PackSendMsg(varhdr, $$$MQTTPUBACK)
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendPUBREC">
<Description><![CDATA[
Creates the variable header of a <b><var>PUBREC</var></b> message and sends the package to the MQTT broker.]]></Description>
<Internal>1</Internal>
<FormalSpec>pMessageId:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set varhdr = $$$MQTTEncodeNumber(+pMessageId)
	
	Set tSC = ..PackSendMsg(varhdr, $$$MQTTPUBREC)
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendPUBREL">
<Description><![CDATA[
Creates the variable header of a <b><var>PUBREL</var></b> message and sends the package to the MQTT broker.]]></Description>
<Internal>1</Internal>
<FormalSpec>pMessageId:%Integer,pDup:%Boolean=0</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set varhdr = $$$MQTTEncodeNumber(+pMessageId)
	
	Set tSC = ..PackSendMsg(varhdr, $$$MQTTPUBREL, pDup, 1)
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendPUBCOMP">
<Description><![CDATA[
Creates the variable header of a <b><var>PUBCOMP</var></b> message and sends the package to the MQTT broker.]]></Description>
<Internal>1</Internal>
<FormalSpec>pMessageId:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set varhdr = $$$MQTTEncodeNumber(+pMessageId)
	
	Set tSC = ..PackSendMsg(varhdr, $$$MQTTPUBCOMP)
	Quit tSC
]]></Implementation>
</Method>

<Method name="RecvCONNACK">
<Description><![CDATA[
Evaluates a <b><var>CONNACK</var></b> message, received from the MQTT Broker and signals the initiator (<class>Net.MQTT.Client</class>)
 via the <class>%SYSTEM.Event</class> API about the success or failure of the connection attempt.]]></Description>
<Internal>1</Internal>
<FormalSpec>pDup:%Boolean,pQoS:%Integer,pRetain:%Boolean,pContent:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	
	Set ret = ""
	If $Length(pContent) '= 2 {
		Set tSC = $$$ERROR($$$GeneralError, "Invalid CONNACK message has arrived from <" _ ..Host _ ":" _ ..Port _ "> (length: " _ $Length(pContent) _ " <> 2)")
	}
	Else {
		Set ret = +$Ascii($Extract(pContent, 2))
		If ret = 1 { Set tSC = $$$ERROR($$$GeneralError, "Connection to <" _ ..Host _ ":" _ ..Port _ "> failed (unacceptable protocol version)") }
		ElseIf ret = 2 { Set tSC = $$$ERROR($$$GeneralError, "Connection to <" _ ..Host _ ":" _ ..Port _ "> failed (identifier rejected)") }
		ElseIf ret = 3 { Set tSC = $$$ERROR($$$GeneralError, "Connection to <" _ ..Host _ ":" _ ..Port _ "> failed (server unavailable)") }
		ElseIf ret = 4 { Set tSC = $$$ERROR($$$GeneralError, "Connection to <" _ ..Host _ ":" _ ..Port _ "> failed (bad username or password)") }
		ElseIf ret = 5 { Set tSC = $$$ERROR($$$GeneralError, "Connection to <" _ ..Host _ ":" _ ..Port _ "> failed (not authorized)") }
	}
	
	Do $System.Event.Signal("^MQTT.Connect(""" _ ..connectionId _ """)", $Select($$$ISOK(tSC): "", 1: $System.Status.GetErrorText(tSC)))
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="RecvPINGRESP">
<Description><![CDATA[
Evaluates a <b><var>PINGRESP</var></b> message, received from the MQTT Broker and clears the <property>lastPing</property> property,
 so the Agent can know that the broker is still responsive and the connection is successfully kept alive.]]></Description>
<Internal>1</Internal>
<FormalSpec>pDup:%Boolean,pQoS:%Integer,pRetain:%Boolean,pContent:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	
	If pContent '= "" {
		Set tSC = $$$ERROR($$$GeneralError, "Invalid PINGRESP message has arrived from <" _ ..Host _ ":" _ ..Port _ ">")
	}
	Else {
		Set ..lastPing = ""
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="RecvUNSUBACK">
<Description><![CDATA[
Evaluates an <b><var>UNSUBACK</var></b> message, received from the MQTT Broker and 
 signals the <class>Net.MQTT.Client</class> waiting for this acknowledge of a previously sent <b><var>UNSUBSCRIBE</var></b> message.]]></Description>
<Internal>1</Internal>
<CodeMode>expression</CodeMode>
<FormalSpec>pDup:%Boolean,pQoS:%Integer,pRetain:%Boolean,pContent:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..RecvAcknowledge("UNSUBACK", pDup, pQoS, pRetain, pContent)
]]></Implementation>
</Method>

<Method name="RecvPUBACK">
<Description><![CDATA[
Evaluates a <b><var>PUBACK</var></b> message, received from the MQTT Broker and 
 signals the <class>Net.MQTT.Client</class> waiting for this acknowledge of a previously published QoS Level 1 message.
<p>This is the end of the message flow of the outgoing message.</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pDup:%Boolean,pQoS:%Integer,pRetain:%Boolean,pContent:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..RecvAcknowledge("PUBACK", pDup, pQoS, pRetain, pContent, .msgid)
	Set:$$$ISOK(tSC) tSC = ##class(Net.MQTT.Auxiliary.MessageStatus).DoneMessageOut(..ClientId, msgid)

	Quit tSC
]]></Implementation>
</Method>

<Method name="RecvPUBREC">
<Description><![CDATA[
Evaluates a <b><var>PUBREC</var></b> message, received from the MQTT Broker and 
 signals the <class>Net.MQTT.Client</class> waiting for this acknowledge of a previously published QoS Level 2 message.
<p>It also pushes the <class>Net.MQTT.Auxiliary.MessageStatus</class> to the next state (a <b><var>PUBREL</var></b> message has to be sent).</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pDup:%Boolean,pQoS:%Integer,pRetain:%Boolean,pContent:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..RecvAcknowledge("PUBREC", pDup, pQoS, pRetain, pContent, .msgid)
	Set:$$$ISOK(tSC) tSC = ##class(Net.MQTT.Auxiliary.MessageStatus).ReleaseMessageOut(..ClientId, msgid)

	Quit tSC
]]></Implementation>
</Method>

<Method name="RecvPUBREL">
<Description><![CDATA[
Evaluates a <b><var>PUBREL</var></b> message, received from the MQTT Broker.
<p>It pushes the <class>Net.MQTT.Auxiliary.MessageStatus</class> to the next state (a <b><var>PUBCOMP</var></b> message has to be sent),
 and cretes a new task (<class>Net.MQTT.Auxiliary.TaskList</class>) to complete the next step of the QoS Level 2 message flow.</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pDup:%Boolean,pQoS:%Integer,pRetain:%Boolean,pContent:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..RecvAcknowledge("PUBREL", pDup, pQoS, pRetain, pContent, .msgid)
	Set:$$$ISOK(tSC) tSC = ##class(Net.MQTT.Auxiliary.MessageStatus).CompleteMessageIn(..ClientId, msgid)
	Set:$$$ISOK(tSC) taskid = ##class(Net.MQTT.Auxiliary.TaskList).CreateNewTask(..connectionId, msgid, "PUBCOMP", .tSC)

	Quit tSC
]]></Implementation>
</Method>

<Method name="RecvPUBCOMP">
<Description><![CDATA[
Evaluates a <b><var>PUBCOMP</var></b> message, received from the MQTT Broker and 
 signals the <class>Net.MQTT.Client</class> waiting for this acknowledge of a previously published QoS Level 2 message.
<p>This is the end of the message flow of the outgoing message.</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pDup:%Boolean,pQoS:%Integer,pRetain:%Boolean,pContent:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..RecvAcknowledge("PUBCOMP", pDup, pQoS, pRetain, pContent, .msgid)
	Set:$$$ISOK(tSC) tSC = ##class(Net.MQTT.Auxiliary.MessageStatus).DoneMessageOut(..ClientId, msgid)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="RecvAcknowledge">
<Description><![CDATA[
Generic method for evaluating an acknowledge type message and signaling the appropriate process via the <class>%SYSTEM.Event</class> API
 waiting for this acknowledge.]]></Description>
<Internal>1</Internal>
<FormalSpec>pType:%String,pDup:%Boolean,pQoS:%Integer,pRetain:%Boolean,pContent:%String,*pMsgId:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	
	If $Length(pContent) '= 2 {
		Set tSC = $$$ERROR($$$GeneralError, "Invalid " _ pType _ " message has arrived from <" _ ..Host _ ":" _ ..Port _ "> (length: " _ $Length(pContent) _ " <> 2)")
	}
	Else {
		Set pMsgId = $$$MQTTDecodeNumber(pContent)
		Do ##class(Net.MQTT.Auxiliary.TaskList).SignalAck(..connectionId, pMsgId, pType, $Select($$$ISOK(tSC): "", 1: $System.Status.GetErrorText(tSC)))
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="RecvSUBACK">
<Description><![CDATA[
Evaluates a <b><var>SUBACK</var></b> message, received from the MQTT Broker,
 stores the QoS levels granted by the broker on the various items of the subscription message (see: <class>Net.MQTT.Auxiliary.Subscription</class>)
 and signals the <class>Net.MQTT.Client</class> waiting for this acknowledge of the previously sent <b><var>SUBSCRIBE</var></b> message.]]></Description>
<Internal>1</Internal>
<FormalSpec>pDup:%Boolean,pQoS:%Integer,pRetain:%Boolean,pContent:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	
	If $Length(pContent) < 2 {
		Set tSC = $$$ERROR($$$GeneralError, "Invalid SUBACK message has arrived from <" _ ..Host _ ":" _ ..Port _ "> (length < 2)")
	}
	Else {
		Set msgid = $$$MQTTDecodeNumber($Extract(pContent, 1, 2))
		Set cnt = ##class(Net.MQTT.Auxiliary.Subscription).GetTopicCount(..ClientId, msgid, .tSC)
		If $$$ISOK(tSC) {
			If $Length(pContent) '= (2 + cnt) {
				Set tSC = $$$ERROR($$$GeneralError, "Invalid SUBACK message has arrived from <" _ ..Host _ ":" _ ..Port _ "> (# of topics)")
			}
			Else {
				For i = 1: 1: cnt {
					Set tSC = ##class(Net.MQTT.Auxiliary.Subscription).AckTopic(..ClientId, msgid, i, $Case($Ascii($Extract(pContent, 2 + i)), $$$MQTTSubQoS2: 2, $$$MQTTSubQoS1: 1, : 0))
					Quit:$$$ISERR(tSC)
				}
			}
		}
		Do ##class(Net.MQTT.Auxiliary.TaskList).SignalAck(..connectionId, msgid, "SUBACK", $Select($$$ISOK(tSC): "", 1: $System.Status.GetErrorText(tSC)))
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="RecvPUBLISH">
<Description><![CDATA[
Evaluates a <b><var>PUBLISH</var></b> message, received from the MQTT Broker and
 sends the incoming message to the <property>OnMessage</property> callback method, which is responsible for
 optionally filtering, processing and storing of the message.
<p>If the QoS Level > 0, it also pushes the <class>Net.MQTT.Auxiliary.MessageStatus</class> to the next state 
 (either a <b><var>PUBACK</var></b> or <b><var>PUBREC</var></b> message has to be sent),
 and cretes a new task (<class>Net.MQTT.Auxiliary.TaskList</class>) to complete the next step of the message flow.</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pDup:%Boolean,pQoS:%Integer,pRetain:%Boolean,pContent:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	
	Set topicL = $$$MQTTDecodeNumber($Extract(pContent, 1, 2))
	Set topic = $Extract(pContent, 3, 2 + topicL)
	Set pos = 3 + topicL
	If pQoS > 0 {
		Set msgid = $$$MQTTDecodeNumber($Extract(pContent, pos, pos + 1))
		Set pos = pos + 2
	}
	Else {
		Set msgid = ""
	}

	TStart
	Set tSC = ##class(Net.MQTT.Auxiliary.MessageStatus).%LockExtent(0)
	TRY {
		Set dup = $Select(pQoS > 0: pDup, 1: 0)
		If pQoS > 0 {
			If dup {
				Set dup = ##class(Net.MQTT.Auxiliary.MessageStatus).IsRegisteredMessageIn(..ClientId, msgid)
			}
			If 'dup {
				Set tSC = ##class(Net.MQTT.Auxiliary.MessageStatus).RegisterMessageIn(..ClientId, msgid, pQoS)
			}

			// The acknowledgement mechanism is independent from the fact, 
			//  whether the application message is a duplicate or not, or it is successfully processed by the OnMessage handler or not.
			Set:$$$ISOK(tSC) taskid = ##class(Net.MQTT.Auxiliary.TaskList).CreateNewTask(..connectionId, msgid, $Case(pQoS, 2: "PUBREC", : "PUBACK"), .tSC)
		}
	}
	CATCH ex {
		Set tSC = ex.AsStatus()
	}
	Do ##class(Net.MQTT.Auxiliary.MessageStatus).%UnlockExtent()
	If $$$ISOK(tSC) { TCommit }
	Else { TRollback }
	Quit:$$$ISERR(tSC) tSC
	
	Do ..ProcessMessage(msgid, topic, $Extract(pContent, pos, *), pDup, pQoS, pRetain)
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ProcessMessage">
<Description><![CDATA[
Evaluates the <property>OnMessage</property> setting, calls the appropriate callback method and handles potential errors.]]></Description>
<FormalSpec>pMsgId:%String,pTopic:%String,pContent:%String,pDuplicate:%Boolean,pQoS:%Integer,pRetain:%Boolean</FormalSpec>
<Implementation><![CDATA[
	Set tSC = $$$OK
	TRY {
		Set cbClass = $Piece(..OnMessage, ":", 1)
		Set cbMethod = $Piece(..OnMessage, ":", 2)
		
		Set message = ##class(Net.MQTT.Message).%New()
		Set message.ClientId = ..ClientId
		Set message.MessageId = pMsgId
		Set message.Topic = pTopic
		Set message.Content = pContent
		Set message.QoSLevel = pQoS
		Set message.Retain = pRetain
		Set tSC = $CLASSMETHOD(cbClass, cbMethod, .message, pDuplicate)
	}
	CATCH ex {
		Set tSC = ex.AsStatus()
	}
	
	If $$$ISERR(tSC) {
		$$$MQTTTraceERR("Message cannot be processed (ID='" _ pMsgId _ "', Content='" + pContent + "'): " _ $System.Status.GetErrorText(tSC))
	}
]]></Implementation>
</Method>

<Method name="CloseDev">
<Internal>1</Internal>
<Private>1</Private>
<Implementation><![CDATA[
	If ..connected {
		$$$MQTTTraceINF("Agent for " _ ..ClientId _ " to <" _ ..Host _ ":" _ ..Port _ "> is stopping TCP connection")
		Close ..device
		Use ..saveIODev
		Set ..connected = 0, ..device = ""
	}
]]></Implementation>
</Method>

<Method name="PackSendMsg">
<Internal>1</Internal>
<FormalSpec>pMessage:%String,pMessageType:%Integer,pDup:%Boolean=0,pQoS:%Integer=0,pRetain:%Boolean=0</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set header = $Char(pMessageType 
		+ $Select(pDup: $$$MQTTDup, 1: 0) 
		+ $Select(pRetain: $$$MQTTRetain, 1: 0) 
		+ $Case(pQoS, 2: $$$MQTTQoS2, 1: $$$MQTTQoS1, : 0)
	)

	Set lng = $Length(pMessage)
	While 1 {
		Set nxt = lng # 128
		Set lng = lng \ 128
		If lng > 0 {
			Set nxt = nxt + 128
		}
		Set header = header _ $Char(nxt)
		Quit:(lng '> 0)
	}

	Set msg = header_pMessage
	Write msg, !
	Set ..lastMessage = $ZDateTime($ZTimeStamp, 3, 1)
	$$$MQTTTraceOUT($$$MQTTMsgType(pMessageType), msg, $$$MQTTTraceInfo) 
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetMessageType">
<ClassMethod>1</ClassMethod>
<FormalSpec>pHeader:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set a = $Factor($Ascii(pHeader))
	Set type = 0
	For i = 5: 1: 8 {
		Set type = type + ($Bit(a, i) * (2 ** (i - 1)))
	}
	 
	Quit type
]]></Implementation>
</Method>

<Method name="IsDuplicate">
<ClassMethod>1</ClassMethod>
<FormalSpec>pHeader:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set a = $Factor($Ascii(pHeader))
	Set b = $Factor($$$MQTTDup)
	Quit $BitLogic(a & b) = b
]]></Implementation>
</Method>

<Method name="GetQoSLevel">
<ClassMethod>1</ClassMethod>
<FormalSpec>pHeader:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set a  = $Factor($Ascii(pHeader))
	Set q1 = $Factor($$$MQTTQoS1)
	Set q2 = $Factor($$$MQTTQoS2)
	Quit $Select($BitLogic(a & q2) = q2: 2, $BitLogic(a & q1) = q1: 1, 1: 0)
]]></Implementation>
</Method>

<Method name="IsRetain">
<ClassMethod>1</ClassMethod>
<FormalSpec>pHeader:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set a = $Factor($Ascii(pHeader))
	Set b = $Factor($$$MQTTRetain)
	Quit $BitLogic(a & b) = b
]]></Implementation>
</Method>

<Method name="GetUTFString">
<FormalSpec>pString:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tString = $ZCVT(pString, "O", ..transTable)
	Set tLen = $L(tString)
	
	Quit $$$MQTTEncodeNumber(tLen) _ tString
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>AgentDefaultData</DefaultData>
<Data name="AgentDefaultData">
<Subscript>"Agent"</Subscript>
<Value name="1">
<Value>connected</Value>
</Value>
<Value name="2">
<Value>device</Value>
</Value>
<Value name="3">
<Value>saveIODev</Value>
</Value>
<Value name="4">
<Value>transTable</Value>
</Value>
<Value name="5">
<Value>lastMessage</Value>
</Value>
<Value name="6">
<Value>lastPing</Value>
</Value>
<Value name="7">
<Value>fatalError</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Net.MQTT.Aux.MessageCounter">
<Description><![CDATA[
Auxiliary class to provide unique Message Identifiers for in-flight messages of a specific client connection.
<p>MQTT standard only specifies that Message Identifiers must be unique among the currently in-flight messages.
This class helps to initialize a new message sequence for each Client (<class>Net.MQTT.Client</class>) / Agent (<class>Net.MQTT.Agent</class>) pairs,
 based on the <property>ClientId</property>. This also means that <property>ClientId</property> must be unique among parallel
 Client instances currently running in the same database.</p>]]></Description>
<Super>%Persistent</Super>
<TimeChanged>64072,53150.105508</TimeChanged>
<TimeCreated>64070,61478.847771</TimeCreated>

<Index name="ClientKey">
<IdKey>1</IdKey>
<PrimaryKey>1</PrimaryKey>
<Properties>ClientId</Properties>
</Index>

<Property name="ClientId">
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="LastMessageId">
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="MAXVAL" value="65535"/>
<Parameter name="MINVAL" value="0"/>
</Property>

<Method name="CreateCounter">
<Description><![CDATA[
Used internally, by <class>Net.MQTT.Client</class> instances to create a new Message Identifier sequence.
for a <property>ClientId</property> (which must be unqique among the currently running Clients). ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClientId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..%LockExtent(0)
	TRY {
		If ..%ExistsId(pClientId) {
			Set tSC = $$$ERROR($$$GeneralError, "Client ID ('" _ pClientId _ "') is already used")
		}
		Else {
			Set obj = ..%New()
			Set obj.ClientId = pClientId
			Set tSC = obj.%Save()
		}
	}
	CATCH ex {
		Set tSC = ex.AsStatus()
	}
	Do ..%UnlockExtent()
	Quit tSC
]]></Implementation>
</Method>

<Method name="NextMessageId">
<Description><![CDATA[
Used internally, by <class>Net.MQTT.Client</class> instances.
<p>Returns the next available Message Idenfier for a specific <property>ClientId</property>.</p>
<p>Currently MQTT Message Identifiers must fall between 1 and 65535. After 65535 the counter simply turns into 1 again,
simply assuming that this cannot lead to a collision among current in-flight messages.</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pClientId:%String,&pSC:%Status]]></FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set obj = ..%OpenId(pClientId, 4, .pSC)
	If $$$ISOK(pSC) {
		Set obj.LastMessageId = $Case(obj.LastMessageId, 65535: 1, : obj.LastMessageId + 1)
		Set pSC = obj.%Save()
	}
	Quit $Select($$$ISOK(pSC): obj.LastMessageId, 1: "")
]]></Implementation>
</Method>

<Method name="DropCounter">
<Description><![CDATA[
Used internally, by <class>Net.MQTT.Client</class> instances.
<p>Deletes the corresponding counter, when a Client is about to stop (more specifically: when its <class>Net.MQTT.Agent</class> is stopped).</p>]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..%DeleteId(pClientId, 4)
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Net.MQTT.Aux.MessageCounterD</DataLocation>
<DefaultData>MessageCounterDefaultData</DefaultData>
<IdLocation>^Net.MQTT.Aux.MessageCounterD</IdLocation>
<IndexLocation>^Net.MQTT.Aux.MessageCounterI</IndexLocation>
<StreamLocation>^Net.MQTT.Aux.MessageCounterS</StreamLocation>
<Data name="MessageCounterDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>LastMessageId</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Net.MQTT.Aux.MessageStatus">
<Description><![CDATA[
Auxiliary class used only internally to keep track of QoS level 1-2 message, while they're waiting for completion of the communication.
<class>This class is used only internally by the <class>Net.MQTT.Client</class> and <class>Net.MQTT.Agent</class> classes.
<p>Messages are delete from this class, as soon as the corresponding message flow is completed.</p>]]></Description>
<Super>%Persistent</Super>
<TimeChanged>64072,54377.648006</TimeChanged>
<TimeCreated>64050,79985.782311</TimeCreated>

<Index name="ClientKey">
<Properties>ClientId,Direction,MessageId</Properties>
<Unique>1</Unique>
</Index>

<Property name="ClientId">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="23"/>
</Property>

<Property name="Direction">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="VALUELIST" value=",I,O"/>
</Property>

<Property name="MessageId">
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="MAXVAL" value="65535"/>
<Parameter name="MINVAL" value="1"/>
</Property>

<Property name="Status">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="VALUELIST" value=",SUBSCRIBE,UNSUBSCRIBE,PUBLISH,PUBACK,PUBREC,PUBREL,PUBCOMP,DONE"/>
</Property>

<Method name="RegisterMessageIn">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String,pQoSLevel:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..RegisterNew(pClientId, pMessageId, "I", $Case(pQoSLevel, 2: "PUBREC", : "PUBACK"))
]]></Implementation>
</Method>

<Method name="IsRegisteredMessageIn">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[..ClientKeyExists(pClientId, "I", pMessageId)
]]></Implementation>
</Method>

<Method name="ReleaseMessageIn">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Update(pClientId, "I", pMessageId, "PUBREL")
]]></Implementation>
</Method>

<Method name="CompleteMessageIn">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Update(pClientId, "I", pMessageId, "PUBCOMP")
]]></Implementation>
</Method>

<Method name="DoneMessageIn">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Done(pClientId, "I", pMessageId)
]]></Implementation>
</Method>

<Method name="RegisterMessageOut">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..RegisterNew(pClientId, pMessageId, "O", "PUBLISH")
]]></Implementation>
</Method>

<Method name="AcknowledgeMessageOut">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Update(pClientId, "O", pMessageId, "PUBACK")
]]></Implementation>
</Method>

<Method name="ReceiveMessageOut">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Update(pClientId, "O", pMessageId, "PUBREC")
]]></Implementation>
</Method>

<Method name="ReleaseMessageOut">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Update(pClientId, "O", pMessageId, "PUBREL")
]]></Implementation>
</Method>

<Method name="CompleteMessageOut">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Update(pClientId, "O", pMessageId, "PUBCOMP")
]]></Implementation>
</Method>

<Method name="DoneMessageOut">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Done(pClientId, "O", pMessageId)
]]></Implementation>
</Method>

<Method name="RegisterNew">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClientId:%String,pMessageId:%String,pDirection:%String,pStatus:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set msgid = ""
	Set tSC = ..%LockExtent(0)
	If $$$ISERR(tSC) { Quit tSC }
	
	TRY {
		Set obj = ..%New()
		Set obj.ClientId = pClientId
		Set obj.Direction = pDirection
		Set obj.MessageId = pMessageId
		Set obj.Status = pStatus
		Set tSC = obj.%Save()
	}
	CATCH ex {
		Set pSC = ex.AsStatus()
	}
	Do ..%UnlockExtent()
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="Update">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClientId:%String,pDirection:%String,pMessageId:%String,pStatus:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..%LockExtent(0)
	If $$$ISERR(tSC) { Quit tSC }

	TRY {
		Set obj = ..ClientKeyOpen(pClientId, pDirection, pMessageId, 0, .tSC)
		If $$$ISOK(tSC) {
			Set obj.Status = pStatus
			Set tSC = obj.%Save()
		}
		Else {
			Set tSC = $$$ERROR($$$GeneralError, "Message ID (" _ pDirection _ "," _ pMessageId _ ") cannot be updated for " _ pClientId)
		}
	}
	CATCH ex {
		Set tSC = ex.AsStatus()
	}
	Do ..%UnlockExtent()
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="Done">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClientId:%String,pDirection:%String,pMessageId:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..%LockExtent(0)
	If $$$ISERR(tSC) { Quit tSC }

	TRY {
		Set exists = ..ClientKeyExists(pClientId, pDirection, pMessageId, .id)
		If exists {
			Set tSC = ..%DeleteId(id, 0)
		}
		Else {
			Set tSC = $$$ERROR($$$GeneralError, "Message ID (" _ pDirection _ "," _ pMessageId _ ") does not currently exists for " _ pClientId)
		}
	}
	CATCH ex {
		Set pSC = ex.AsStatus()
	}
	Do ..%UnlockExtent()
	
	Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Net.MQTT.Aux.MessageStatusD</DataLocation>
<DefaultData>MessageStatusDefaultData</DefaultData>
<IdLocation>^Net.MQTT.Aux.MessageStatusD</IdLocation>
<IndexLocation>^Net.MQTT.Aux.MessageStatusI</IndexLocation>
<StreamLocation>^Net.MQTT.Aux.MessageStatusS</StreamLocation>
<Data name="MessageStatusDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ClientId</Value>
</Value>
<Value name="3">
<Value>MessageId</Value>
</Value>
<Value name="4">
<Value>Status</Value>
</Value>
<Value name="5">
<Value>Direction</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Net.MQTT.Aux.Subscription">
<Description><![CDATA[
Auxiliary class is used only internally by a <class>Net.MQTT.Client</class> and its <class>Net.MQTT.Agent</class> to keep track of 
<b><var>SUBSCRIBE</var></b> and <b><var>UNSUBSCRIBE</var></b> message contents.
<p>These messages must have a unique Message Idenfier among current in-flight messages (per Client), 
 therefore all instances are dropped as soon as the corresponding message flow is completed.</p>]]></Description>
<IncludeCode>MQTTOptions</IncludeCode>
<Super>%Persistent</Super>
<TimeChanged>64072,53677.046645</TimeChanged>
<TimeCreated>64050,80453.857656</TimeCreated>

<Index name="ClientKey">
<Properties>ClientId,MessageId</Properties>
<Unique>1</Unique>
</Index>

<Property name="ClientId">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="23"/>
</Property>

<Property name="MessageId">
<Type>%Integer</Type>
<Required>1</Required>
<Parameter name="MAXVAL" value="65653"/>
<Parameter name="MINVAL" value="1"/>
</Property>

<Property name="Topics">
<Type>Net.MQTT.Aux.SubscriptionTopic</Type>
<Cardinality>children</Cardinality>
<Inverse>Subscription</Inverse>
<Relationship>1</Relationship>
</Property>

<Method name="CreateSubscription">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pClientId:%String,pMessageId:%String,&pSC:%Status]]></FormalSpec>
<ReturnType>Net.MQTT.Aux.Subscription</ReturnType>
<Implementation><![CDATA[
	Set obj = ..%New()
	Set obj.ClientId = pClientId
	Set obj.MessageId = pMessageId
	Set pSC = obj.%Save()
	
	Quit $Select($$$ISOK(pSC): obj, 1: "")
]]></Implementation>
</Method>

<Method name="DropSubscription">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..%DeleteId(pId)
]]></Implementation>
</Method>

<Method name="AddTopic">
<FormalSpec>pTopic:Net.MQTT.Message</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set obj = ##class(Net.MQTT.Aux.SubscriptionTopic).%New()
	Set obj.Topic = pTopic.Topic
	Set obj.QoSLevel = pTopic.QoSLevel
	Set tSC = ..Topics.Insert(obj)
	Set:$$$ISOK(tSC) tSC = ..%Save()
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetTopicCount">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pClientId:%String,pMessageId:%String,&pSC:%Status]]></FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set ret = ""
	Set obj = ..ClientKeyOpen(pClientId, pMessageId, 0, .pSC)
	If $$$ISOK(pSC) {
		Set ret = obj.Topics.Count()
	}
	
	Quit ret
]]></Implementation>
</Method>

<Method name="GetTopicList">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pClientId:%String,pMessageId:%String,&pSC:%Status]]></FormalSpec>
<ReturnType>%ListOfObjects</ReturnType>
<ReturnTypeParams>ELEMENTTYPE="Net.MQTT.Message"</ReturnTypeParams>
<Implementation><![CDATA[
 	Set ret = ##class(%ListOfObjects).%New()
	Set obj = ..ClientKeyOpen(pClientId, pMessageId, -1, .pSC)
	If $$$ISOK(pSC) {
		For i = 1: 1: obj.Topics.Count() {
			Set next = obj.Topics.GetAt(i)
			
			Set msg = ##class(Net.MQTT.Message).%New()
			Set msg.Topic = next.Topic
			Set msg.QoSLevel = next.QoSLevel
			Set pSC = ret.Insert(msg)
			Quit:$$$ISERR(pSC)
		}
	}
 	
	Quit $Select($$$ISOK(pSC): ret, 1: "")
]]></Implementation>
</Method>

<Method name="AckTopic">
<ClassMethod>1</ClassMethod>
<FormalSpec>pClientId:%String,pMessageId:%String,pTopicNr:%Integer,pGrantedQoS:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set obj = ..ClientKeyOpen(pClientId, pMessageId, -1, .tSC)
	If $$$ISOK(tSC) {
		If (pTopicNr < 1) || (pTopicNr > obj.Topics.Count()) {
			Set tSC = $$$ERROR($$$GeneralError, "Inavlid topic number (" _ pTopicNr _ " is not between 1 and " _ obj.Topics.Count() _ ")")
		}
		Else {
			Set topic = obj.Topics.GetAt(pTopicNr)
			Set topic.GrantedQoS = pGrantedQoS
			Set tSC = topic.%Save()
		}
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="RetrieveAck">
<FormalSpec><![CDATA[&pTopics:%ListOfObjects(ELEMENTTYPE="Net.MQTT.Message")]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..%Reload()
	If $$$ISOK(tSC) {
		If pTopics.Count() '= ..Topics.Count() {
			Set tSC = $$$ERROR($$$GeneralError, "Topic count mismatch (" _ pTopics.Count() _ " <> " _ ..Topics.Count() _ ")")
		}
		Else {
			For i = 1: 1: pTopics.Count() {
				Set pTopics.GetAt(i).GrantedQoS = ..Topics.GetAt(i).GrantedQoS
			}
		}
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Net.MQTT.Aux.SubscriptionD</DataLocation>
<DefaultData>SubscriptionDefaultData</DefaultData>
<IdLocation>^Net.MQTT.Aux.SubscriptionD</IdLocation>
<IndexLocation>^Net.MQTT.Aux.SubscriptionI</IndexLocation>
<StreamLocation>^Net.MQTT.Aux.SubscriptionS</StreamLocation>
<Data name="SubscriptionDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ClientId</Value>
</Value>
<Value name="3">
<Value>MessageId</Value>
</Value>
<Value name="4">
<Value>TopicNr</Value>
</Value>
<Value name="5">
<Value>Topic</Value>
</Value>
<Value name="6">
<Value>QoSLevel</Value>
</Value>
<Value name="7">
<Value>GrantedQoS</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Net.MQTT.Aux.SubscriptionTopic">
<Description><![CDATA[
Auxiliary class is used only internally by a <class>Net.MQTT.Client</class> and its <class>Net.MQTT.Agent</class>.
<p>Provides the topic list, which the primary content of <b><var>SUBSCRIBE</var></b> and <b><var>UNSUBSCRIBE</var></b> messages.</p>]]></Description>
<Super>%Persistent</Super>
<TimeChanged>64125,74010.460237</TimeChanged>
<TimeCreated>64050,80453.857656</TimeCreated>

<Index name="TopicKey">
<Properties>Subscription,Topic</Properties>
<Unique>1</Unique>
</Index>

<Property name="Subscription">
<Type>Net.MQTT.Aux.Subscription</Type>
<Cardinality>parent</Cardinality>
<Inverse>Topics</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Topic">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN"/>
</Property>

<Property name="QoSLevel">
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="VALUELIST" value=",0,1,2"/>
</Property>

<Property name="GrantedQoS">
<Type>%Integer</Type>
<Parameter name="VALUELIST" value=",0,1,2"/>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Net.MQTT.Aux.Subscriptio1311D</DataLocation>
<DefaultData>SubscriptionTopicDefaultData</DefaultData>
<IdLocation>^Net.MQTT.Aux.Subscriptio1311D</IdLocation>
<IndexLocation>^Net.MQTT.Aux.Subscriptio1311I</IndexLocation>
<StreamLocation>^Net.MQTT.Aux.Subscriptio1311S</StreamLocation>
<Data name="SubscriptionTopicDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Subscription</Value>
</Value>
<Value name="3">
<Value>Topic</Value>
</Value>
<Value name="4">
<Value>QoSLevel</Value>
</Value>
<Value name="5">
<Value>GrantedQoS</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Net.MQTT.Aux.TaskList">
<Description><![CDATA[
Auxiliary class is used only internally, which proides an event-drivn interface for a <class>Net.MQTT.Client</class> and its <class>Net.MQTT.Agent</class>.]]></Description>
<Super>%Persistent</Super>
<TimeChanged>64073,2824.483814</TimeChanged>
<TimeCreated>64051,66904.675697</TimeCreated>

<Property name="ConnectionId">
<Description><![CDATA[
<property>connectionId</property> property of the corresponding <class>Net.MQTT.Client</class> and <class>Net.MQTT.Agent</class> objects.]]></Description>
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="ContextId">
<Description>
Task-dependent context identifier. The cretor and processor of the task must agree on the meaning of this string. </Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Action">
<Description>
List of actions, which require an event-driven interface.</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="VALUELIST" value=",DISCONNECT,SUBSCRIBE,UNSUBSCRIBE,PUBLISH,PUBACK,PUBREC,PUBREL,PUBCOMP"/>
</Property>

<Property name="Status">
<Description><![CDATA[
Current status of the task:<ul>
<li><b><var>0</var></b> - <b><var>Pending</var></b>, waiting for being processed.</li>
<li><b><var>1</var></b> - <b><var>In progress</var></b>, the <class>Net.MQTT.Agent</class> already picked up the task.</li>
<li><b><var>2</var></b> - <b><var>Done</var></b>, and kept for debugging purposes.</li>
</ul>]]></Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
<Parameter name="MAXVAL" value="2"/>
<Parameter name="MINVAL" value="0"/>
</Property>

<Method name="WaitAck">
<Description><![CDATA[
Called when a particular message (identified by <var>pMessageId</var>) of a client connection is waiting for an event.
<p>The <class>%SYSTEM.Event</class> API is used to implement this, for detailed explanation of the return value, see that class documentation!</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pConnectionId:%String,pMessageId:%String,pStatus:%String,pTimeout:%Integer=-1</FormalSpec>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	Set ret = ""
	Do $System.Event.Create("^MQTT.Message(""" _ pConnectionId _ """,""" _ pMessageId _ """,""" _ pStatus _ """)")
	Set ret = $System.Event.WaitMsg("^MQTT.Message(""" _ pConnectionId _ """,""" _ pMessageId _ """,""" _ pStatus _ """)", pTimeout)
	
	Quit ret
]]></Implementation>
</Method>

<Method name="SignalAck">
<Description><![CDATA[
Called to trigger an event of a particular message (identified by <var>pMessageId</var>) of a client connection.
<p>The <class>%SYSTEM.Event</class> API is used to implement this, for detailed explanation of the return value, see that class documentation!</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pConnectionId:%String,pMessageId:%String,pStatus:%String,pContent:%String=""</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Do $System.Event.Create("^MQTT.Message(""" _ pConnectionId _ """,""" _ pMessageId _ """,""" _ pStatus _ """)")
	Quit $System.Event.Signal("^MQTT.Message(""" _ pConnectionId _ """,""" _ pMessageId _ """,""" _ pStatus _ """)", pContent)
]]></Implementation>
</Method>

<Method name="WaitTask">
<Description><![CDATA[
Creates a task and waits until it will be completed.
<p>The <class>%SYSTEM.Event</class> API is used to implement this, for detailed explanation of the return value, see that class documentation!</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pConnectionId:%String,pContextId:%String,pAction:%String,pTimeout:%Integer=-1,&pSC:%Status]]></FormalSpec>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	Set ret = ""
	Set taskId = ..CreateNewTask(pConnectionId, pContextId, pAction, .pSC)
	If $$$ISOK(pSC) {
		Do $System.Event.Create("^MQTT.Task(""" _ pConnectionId _ """,""" _ taskId _ """)")
		Set ret = $System.Event.WaitMsg("^MQTT.Task(""" _ pConnectionId _ """,""" _taskId _ """)", pTimeout)
	}
	
	Quit ret
]]></Implementation>
</Method>

<Method name="SignalTask">
<Description><![CDATA[
Signals the completion of a task.
<p><var>pStatusCode</p> is the return status of the method, which processed the task.</p>
<p><var>pDebugMode</p> shows, whether the <class>Net.MQTT.Aux.TaskList</class> object has to be kept for debugging purposes,
 or can be deleted.</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pConnectionId:%String,pTaskId:%String,pStatusCode:%Status,pDebugMode:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do $System.Event.Signal("^MQTT.Task(""" _ pConnectionId _ """,""" _ pTaskId _ """)", $Select($$$ISOK(pStatusCode): "", 1: $System.Status.GetErrorText(pStatusCode)))
	Set tSC = ..CompleteTask(pTaskId, pDebugMode)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="CreateNewTask">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pConnectionId:%String,pContextId:%String,pAction:%String,&pSC:%Status]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set obj = ..%New()
	Set obj.ConnectionId = pConnectionId
	Set obj.ContextId = pContextId
	Set obj.Action = pAction
	Set pSC = obj.%Save()
	Quit $Select($$$ISOK(pSC): obj.%Id(), 1: "")
]]></Implementation>
</Method>

<Method name="AcquireNext">
<ClassMethod>1</ClassMethod>
<FormalSpec>pConnectionId:%String,*pTaskId:%String,*pContextId:%String,*pAction:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set (pTaskId, pContextId, pAction) = ""
	Lock +^Net.MQTT.Aux.TaskListD:5 Quit:('$Test) $$$ERROR($$$GeneralError, "Task table lock failed")
	TRY {
		&sql(SELECT TOP 1 
			ID, ContextId, Action 
		INTO 
			:pTaskId, :pContextId, :pAction
		FROM
			Net_MQTT_Aux.TaskList
		WHERE
			ConnectionId = :pConnectionId AND Status = 0
		)
		If $Get(SQLCODE, 0) {
			If (SQLCODE '= 100) {
				Set tSC = $$$ERROR($$$GeneralError, "Task table query failed (" _ SQLCODE _ ")")
			}
		}
		Else {
			Set tSC = ..AcquireTask(pTaskId)
		}
	}
	CATCH ex {
		Set tSC = ex.AsStatus()
	}
	Lock -^Net.MQTT.Aux.TaskListD
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="AcquireTask">
<ClassMethod>1</ClassMethod>
<FormalSpec>pTaskId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set obj = ..%OpenId(pTaskId, 4)
	If $IsObject(obj) {
		Set obj.Status = 1
		Set tSC = obj.%Save()
	}
	Else {
		Set tSC = $$$ERROR($$$GeneralError, "Task cannot be found (id = " _ pTaskId _ ")")
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="CompleteTask">
<ClassMethod>1</ClassMethod>
<FormalSpec>pTaskId:%String,pKeepIt:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK, found = 0
	If pKeepIt {
		Set obj = ..%OpenId(pTaskId, 4)
		If $IsObject(obj) {
			Set found = 1
			Set obj.Status = 2
			Set tSC = obj.%Save()
		}
	}
	Else {
		Set found = $$$ISOK(..%DeleteId(pTaskId, 4))
	}

	If 'found {
		Set tSC = $$$ERROR($$$GeneralError, "Task cannot be found (id = " _ pTaskId _ ")")
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Net.MQTT.Aux.TaskListD</DataLocation>
<DefaultData>TaskListDefaultData</DefaultData>
<IdLocation>^Net.MQTT.Aux.TaskListD</IdLocation>
<IndexLocation>^Net.MQTT.Aux.TaskListI</IndexLocation>
<StreamLocation>^Net.MQTT.Aux.TaskListS</StreamLocation>
<Data name="TaskListDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ConnectionId</Value>
</Value>
<Value name="3">
<Value>ContextId</Value>
</Value>
<Value name="4">
<Value>Action</Value>
</Value>
<Value name="5">
<Value>Status</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Net.MQTT.Auxiliary.MessageCounter">
<Description><![CDATA[
Auxiliary class to provide unique Message Identifiers for in-flight messages of a specific client connection.
<p>MQTT standard only specifies that Message Identifiers must be unique among the currently in-flight messages.
This class helps to initialize a new message sequence for each Client (<class>Net.MQTT.Client</class>) / Agent (<class>Net.MQTT.Agent</class>) pairs,
 based on the <property>ClientId</property>. This also means that <property>ClientId</property> must be unique among parallel
 Client instances currently running in the same database.</p>]]></Description>
<Super>%Persistent</Super>
<TimeChanged>64138,82668.950865</TimeChanged>
<TimeCreated>64070,61478.847771</TimeCreated>

<Index name="ClientKey">
<IdKey>1</IdKey>
<PrimaryKey>1</PrimaryKey>
<Properties>ClientId</Properties>
</Index>

<Property name="ClientId">
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="LastMessageId">
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="MAXVAL" value="65535"/>
<Parameter name="MINVAL" value="0"/>
</Property>

<Method name="CreateCounter">
<Description><![CDATA[
Used internally, by <class>Net.MQTT.Client</class> instances to create a new Message Identifier sequence.
for a <property>ClientId</property> (which must be unqique among the currently running Clients). ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClientId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..%LockExtent(0)
	TRY {
		If ..%ExistsId(pClientId) {
			Set tSC = $$$ERROR($$$GeneralError, "Client ID ('" _ pClientId _ "') is already used")
		}
		Else {
			Set obj = ..%New()
			Set obj.ClientId = pClientId
			Set tSC = obj.%Save()
		}
	}
	CATCH ex {
		Set tSC = ex.AsStatus()
	}
	Do ..%UnlockExtent()
	Quit tSC
]]></Implementation>
</Method>

<Method name="NextMessageId">
<Description><![CDATA[
Used internally, by <class>Net.MQTT.Client</class> instances.
<p>Returns the next available Message Idenfier for a specific <property>ClientId</property>.</p>
<p>Currently MQTT Message Identifiers must fall between 1 and 65535. After 65535 the counter simply turns into 1 again,
simply assuming that this cannot lead to a collision among current in-flight messages.</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pClientId:%String,&pSC:%Status]]></FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set obj = ..%OpenId(pClientId, 4, .pSC)
	If $$$ISOK(pSC) {
		Set obj.LastMessageId = $Case(obj.LastMessageId, 65535: 1, : obj.LastMessageId + 1)
		Set pSC = obj.%Save()
	}
	Quit $Select($$$ISOK(pSC): obj.LastMessageId, 1: "")
]]></Implementation>
</Method>

<Method name="DropCounter">
<Description><![CDATA[
Used internally, by <class>Net.MQTT.Client</class> instances.
<p>Deletes the corresponding counter, when a Client is about to stop (more specifically: when its <class>Net.MQTT.Agent</class> is stopped).</p>]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..%DeleteId(pClientId, 4)
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Net.MQTT.Aux93C.MessageCounterD</DataLocation>
<DefaultData>MessageCounterDefaultData</DefaultData>
<IdLocation>^Net.MQTT.Aux93C.MessageCounterD</IdLocation>
<IndexLocation>^Net.MQTT.Aux93C.MessageCounterI</IndexLocation>
<StreamLocation>^Net.MQTT.Aux93C.MessageCounterS</StreamLocation>
<Data name="MessageCounterDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>LastMessageId</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Net.MQTT.Auxiliary.MessageStatus">
<Description><![CDATA[
Auxiliary class used only internally to keep track of QoS level 1-2 message, while they're waiting for completion of the communication.
<class>This class is used only internally by the <class>Net.MQTT.Client</class> and <class>Net.MQTT.Agent</class> classes.
<p>Messages are delete from this class, as soon as the corresponding message flow is completed.</p>]]></Description>
<Super>%Persistent</Super>
<TimeChanged>64138,82698.167565</TimeChanged>
<TimeCreated>64050,79985.782311</TimeCreated>

<Index name="ClientKey">
<Properties>ClientId,Direction,MessageId</Properties>
<Unique>1</Unique>
</Index>

<Property name="ClientId">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="23"/>
</Property>

<Property name="Direction">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="VALUELIST" value=",I,O"/>
</Property>

<Property name="MessageId">
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="MAXVAL" value="65535"/>
<Parameter name="MINVAL" value="1"/>
</Property>

<Property name="Status">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="VALUELIST" value=",SUBSCRIBE,UNSUBSCRIBE,PUBLISH,PUBACK,PUBREC,PUBREL,PUBCOMP,DONE"/>
</Property>

<Method name="RegisterMessageIn">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String,pQoSLevel:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..RegisterNew(pClientId, pMessageId, "I", $Case(pQoSLevel, 2: "PUBREC", : "PUBACK"))
]]></Implementation>
</Method>

<Method name="IsRegisteredMessageIn">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[..ClientKeyExists(pClientId, "I", pMessageId)
]]></Implementation>
</Method>

<Method name="ReleaseMessageIn">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Update(pClientId, "I", pMessageId, "PUBREL")
]]></Implementation>
</Method>

<Method name="CompleteMessageIn">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Update(pClientId, "I", pMessageId, "PUBCOMP")
]]></Implementation>
</Method>

<Method name="DoneMessageIn">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Done(pClientId, "I", pMessageId)
]]></Implementation>
</Method>

<Method name="RegisterMessageOut">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..RegisterNew(pClientId, pMessageId, "O", "PUBLISH")
]]></Implementation>
</Method>

<Method name="AcknowledgeMessageOut">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Update(pClientId, "O", pMessageId, "PUBACK")
]]></Implementation>
</Method>

<Method name="ReceiveMessageOut">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Update(pClientId, "O", pMessageId, "PUBREC")
]]></Implementation>
</Method>

<Method name="ReleaseMessageOut">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Update(pClientId, "O", pMessageId, "PUBREL")
]]></Implementation>
</Method>

<Method name="CompleteMessageOut">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Update(pClientId, "O", pMessageId, "PUBCOMP")
]]></Implementation>
</Method>

<Method name="DoneMessageOut">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Done(pClientId, "O", pMessageId)
]]></Implementation>
</Method>

<Method name="RegisterNew">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClientId:%String,pMessageId:%String,pDirection:%String,pStatus:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set msgid = ""
	Set tSC = ..%LockExtent(0)
	If $$$ISERR(tSC) { Quit tSC }
	
	TRY {
		Set obj = ..%New()
		Set obj.ClientId = pClientId
		Set obj.Direction = pDirection
		Set obj.MessageId = pMessageId
		Set obj.Status = pStatus
		Set tSC = obj.%Save()
	}
	CATCH ex {
		Set pSC = ex.AsStatus()
	}
	Do ..%UnlockExtent()
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="Update">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClientId:%String,pDirection:%String,pMessageId:%String,pStatus:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..%LockExtent(0)
	If $$$ISERR(tSC) { Quit tSC }

	TRY {
		Set obj = ..ClientKeyOpen(pClientId, pDirection, pMessageId, 0, .tSC)
		If $$$ISOK(tSC) {
			Set obj.Status = pStatus
			Set tSC = obj.%Save()
		}
		Else {
			Set tSC = $$$ERROR($$$GeneralError, "Message ID (" _ pDirection _ "," _ pMessageId _ ") cannot be updated for " _ pClientId)
		}
	}
	CATCH ex {
		Set tSC = ex.AsStatus()
	}
	Do ..%UnlockExtent()
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="Done">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClientId:%String,pDirection:%String,pMessageId:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..%LockExtent(0)
	If $$$ISERR(tSC) { Quit tSC }

	TRY {
		Set exists = ..ClientKeyExists(pClientId, pDirection, pMessageId, .id)
		If exists {
			Set tSC = ..%DeleteId(id, 0)
		}
		Else {
			Set tSC = $$$ERROR($$$GeneralError, "Message ID (" _ pDirection _ "," _ pMessageId _ ") does not currently exists for " _ pClientId)
		}
	}
	CATCH ex {
		Set pSC = ex.AsStatus()
	}
	Do ..%UnlockExtent()
	
	Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Net.MQTT.Auxi93C.MessageStatusD</DataLocation>
<DefaultData>MessageStatusDefaultData</DefaultData>
<IdLocation>^Net.MQTT.Auxi93C.MessageStatusD</IdLocation>
<IndexLocation>^Net.MQTT.Auxi93C.MessageStatusI</IndexLocation>
<StreamLocation>^Net.MQTT.Auxi93C.MessageStatusS</StreamLocation>
<Data name="MessageStatusDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ClientId</Value>
</Value>
<Value name="3">
<Value>Direction</Value>
</Value>
<Value name="4">
<Value>MessageId</Value>
</Value>
<Value name="5">
<Value>Status</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Net.MQTT.Auxiliary.Subscription">
<Description><![CDATA[
Auxiliary class is used only internally by a <class>Net.MQTT.Client</class> and its <class>Net.MQTT.Agent</class> to keep track of 
<b><var>SUBSCRIBE</var></b> and <b><var>UNSUBSCRIBE</var></b> message contents.
<p>These messages must have a unique Message Idenfier among current in-flight messages (per Client), 
 therefore all instances are dropped as soon as the corresponding message flow is completed.</p>]]></Description>
<IncludeCode>MQTTOptions</IncludeCode>
<Super>%Persistent</Super>
<TimeChanged>64138,82815.465679</TimeChanged>
<TimeCreated>64050,80453.857656</TimeCreated>

<Index name="ClientKey">
<Properties>ClientId,MessageId</Properties>
<Unique>1</Unique>
</Index>

<Property name="ClientId">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="23"/>
</Property>

<Property name="MessageId">
<Type>%Integer</Type>
<Required>1</Required>
<Parameter name="MAXVAL" value="65653"/>
<Parameter name="MINVAL" value="1"/>
</Property>

<Property name="Topics">
<Type>Net.MQTT.Auxiliary.SubscriptionTopic</Type>
<Cardinality>children</Cardinality>
<Inverse>Subscription</Inverse>
<Relationship>1</Relationship>
</Property>

<Method name="CreateSubscription">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pClientId:%String,pMessageId:%String,&pSC:%Status]]></FormalSpec>
<ReturnType>Net.MQTT.Auxiliary.Subscription</ReturnType>
<Implementation><![CDATA[
	Set obj = ..%New()
	Set obj.ClientId = pClientId
	Set obj.MessageId = pMessageId
	Set pSC = obj.%Save()
	
	Quit $Select($$$ISOK(pSC): obj, 1: "")
]]></Implementation>
</Method>

<Method name="DropSubscription">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..%DeleteId(pId)
]]></Implementation>
</Method>

<Method name="AddTopic">
<FormalSpec>pTopic:Net.MQTT.Message</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set obj = ##class(Net.MQTT.Auxiliary.SubscriptionTopic).%New()
	Set obj.Topic = pTopic.Topic
	Set obj.QoSLevel = pTopic.QoSLevel
	Set tSC = ..Topics.Insert(obj)
	Set:$$$ISOK(tSC) tSC = ..%Save()
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetTopicCount">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pClientId:%String,pMessageId:%String,&pSC:%Status]]></FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set ret = ""
	Set obj = ..ClientKeyOpen(pClientId, pMessageId, 0, .pSC)
	If $$$ISOK(pSC) {
		Set ret = obj.Topics.Count()
	}
	
	Quit ret
]]></Implementation>
</Method>

<Method name="GetTopicList">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pClientId:%String,pMessageId:%String,&pSC:%Status]]></FormalSpec>
<ReturnType>%ListOfObjects</ReturnType>
<ReturnTypeParams>ELEMENTTYPE="Net.MQTT.Message"</ReturnTypeParams>
<Implementation><![CDATA[
 	Set ret = ##class(%ListOfObjects).%New()
	Set obj = ..ClientKeyOpen(pClientId, pMessageId, -1, .pSC)
	If $$$ISOK(pSC) {
		For i = 1: 1: obj.Topics.Count() {
			Set next = obj.Topics.GetAt(i)
			
			Set msg = ##class(Net.MQTT.Message).%New()
			Set msg.Topic = next.Topic
			Set msg.QoSLevel = next.QoSLevel
			Set pSC = ret.Insert(msg)
			Quit:$$$ISERR(pSC)
		}
	}
 	
	Quit $Select($$$ISOK(pSC): ret, 1: "")
]]></Implementation>
</Method>

<Method name="AckTopic">
<ClassMethod>1</ClassMethod>
<FormalSpec>pClientId:%String,pMessageId:%String,pTopicNr:%Integer,pGrantedQoS:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set obj = ..ClientKeyOpen(pClientId, pMessageId, -1, .tSC)
	If $$$ISOK(tSC) {
		If (pTopicNr < 1) || (pTopicNr > obj.Topics.Count()) {
			Set tSC = $$$ERROR($$$GeneralError, "Inavlid topic number (" _ pTopicNr _ " is not between 1 and " _ obj.Topics.Count() _ ")")
		}
		Else {
			Set topic = obj.Topics.GetAt(pTopicNr)
			Set topic.GrantedQoS = pGrantedQoS
			Set tSC = topic.%Save()
		}
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="RetrieveAck">
<FormalSpec><![CDATA[&pTopics:%ListOfObjects(ELEMENTTYPE="Net.MQTT.Message")]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..%Reload()
	If $$$ISOK(tSC) {
		If pTopics.Count() '= ..Topics.Count() {
			Set tSC = $$$ERROR($$$GeneralError, "Topic count mismatch (" _ pTopics.Count() _ " <> " _ ..Topics.Count() _ ")")
		}
		Else {
			For i = 1: 1: pTopics.Count() {
				Set pTopics.GetAt(i).GrantedQoS = ..Topics.GetAt(i).GrantedQoS
			}
		}
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Net.MQTT.Auxil93C.SubscriptionD</DataLocation>
<DefaultData>SubscriptionDefaultData</DefaultData>
<IdLocation>^Net.MQTT.Auxil93C.SubscriptionD</IdLocation>
<IndexLocation>^Net.MQTT.Auxil93C.SubscriptionI</IndexLocation>
<StreamLocation>^Net.MQTT.Auxil93C.SubscriptionS</StreamLocation>
<Data name="SubscriptionDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ClientId</Value>
</Value>
<Value name="3">
<Value>MessageId</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Net.MQTT.Auxiliary.SubscriptionTopic">
<Description><![CDATA[
Auxiliary class is used only internally by a <class>Net.MQTT.Client</class> and its <class>Net.MQTT.Agent</class>.
<p>Provides the topic list, which the primary content of <b><var>SUBSCRIBE</var></b> and <b><var>UNSUBSCRIBE</var></b> messages.</p>]]></Description>
<Super>%Persistent</Super>
<TimeChanged>64152,52574.606659</TimeChanged>
<TimeCreated>64050,80453.857656</TimeCreated>

<Index name="TopicKey">
<Properties>Subscription,Topic</Properties>
<Unique>1</Unique>
</Index>

<Property name="Subscription">
<Type>Net.MQTT.Auxiliary.Subscription</Type>
<Cardinality>parent</Cardinality>
<Inverse>Topics</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Topic">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN"/>
</Property>

<Property name="QoSLevel">
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="VALUELIST" value=",0,1,2"/>
</Property>

<Property name="GrantedQoS">
<Type>%Integer</Type>
<Parameter name="VALUELIST" value=",0,1,2"/>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>{%%PARENT}("Topics")</DataLocation>
<DefaultData>SubscriptionTopicDefaultData</DefaultData>
<IdLocation>^Net.MQTT.Auxil93C.SubscriptionC("Topics")</IdLocation>
<IndexLocation>^Net.MQTT.Au93C.Subscriptio1311I</IndexLocation>
<StreamLocation>^Net.MQTT.Au93C.Subscriptio1311S</StreamLocation>
<Data name="SubscriptionTopicDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Topic</Value>
</Value>
<Value name="3">
<Value>QoSLevel</Value>
</Value>
<Value name="4">
<Value>GrantedQoS</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Net.MQTT.Auxiliary.TaskList">
<Description><![CDATA[
Auxiliary class is used only internally, which proides an event-drivn interface for a <class>Net.MQTT.Client</class> and its <class>Net.MQTT.Agent</class>.]]></Description>
<Super>%Persistent</Super>
<TimeChanged>64138,82875.607597</TimeChanged>
<TimeCreated>64051,66904.675697</TimeCreated>

<Property name="ConnectionId">
<Description><![CDATA[
<property>connectionId</property> property of the corresponding <class>Net.MQTT.Client</class> and <class>Net.MQTT.Agent</class> objects.]]></Description>
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="ContextId">
<Description>
Task-dependent context identifier. The cretor and processor of the task must agree on the meaning of this string. </Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Action">
<Description>
List of actions, which require an event-driven interface.</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="VALUELIST" value=",DISCONNECT,SUBSCRIBE,UNSUBSCRIBE,PUBLISH,PUBACK,PUBREC,PUBREL,PUBCOMP"/>
</Property>

<Property name="Status">
<Description><![CDATA[
Current status of the task:<ul>
<li><b><var>0</var></b> - <b><var>Pending</var></b>, waiting for being processed.</li>
<li><b><var>1</var></b> - <b><var>In progress</var></b>, the <class>Net.MQTT.Agent</class> already picked up the task.</li>
<li><b><var>2</var></b> - <b><var>Done</var></b>, and kept for debugging purposes.</li>
</ul>]]></Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
<Parameter name="MAXVAL" value="2"/>
<Parameter name="MINVAL" value="0"/>
</Property>

<Method name="WaitAck">
<Description><![CDATA[
Called when a particular message (identified by <var>pMessageId</var>) of a client connection is waiting for an event.
<p>The <class>%SYSTEM.Event</class> API is used to implement this, for detailed explanation of the return value, see that class documentation!</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pConnectionId:%String,pMessageId:%String,pStatus:%String,pTimeout:%Integer=-1</FormalSpec>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	Set ret = ""
	Do $System.Event.Create("^MQTT.Message(""" _ pConnectionId _ """,""" _ pMessageId _ """,""" _ pStatus _ """)")
	Set ret = $System.Event.WaitMsg("^MQTT.Message(""" _ pConnectionId _ """,""" _ pMessageId _ """,""" _ pStatus _ """)", pTimeout)
	
	Quit ret
]]></Implementation>
</Method>

<Method name="SignalAck">
<Description><![CDATA[
Called to trigger an event of a particular message (identified by <var>pMessageId</var>) of a client connection.
<p>The <class>%SYSTEM.Event</class> API is used to implement this, for detailed explanation of the return value, see that class documentation!</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pConnectionId:%String,pMessageId:%String,pStatus:%String,pContent:%String=""</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Do $System.Event.Create("^MQTT.Message(""" _ pConnectionId _ """,""" _ pMessageId _ """,""" _ pStatus _ """)")
	Quit $System.Event.Signal("^MQTT.Message(""" _ pConnectionId _ """,""" _ pMessageId _ """,""" _ pStatus _ """)", pContent)
]]></Implementation>
</Method>

<Method name="WaitTask">
<Description><![CDATA[
Creates a task and waits until it will be completed.
<p>The <class>%SYSTEM.Event</class> API is used to implement this, for detailed explanation of the return value, see that class documentation!</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pConnectionId:%String,pContextId:%String,pAction:%String,pTimeout:%Integer=-1,&pSC:%Status]]></FormalSpec>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	Set ret = ""
	Set taskId = ..CreateNewTask(pConnectionId, pContextId, pAction, .pSC)
	If $$$ISOK(pSC) {
		Do $System.Event.Create("^MQTT.Task(""" _ pConnectionId _ """,""" _ taskId _ """)")
		Set ret = $System.Event.WaitMsg("^MQTT.Task(""" _ pConnectionId _ """,""" _taskId _ """)", pTimeout)
	}
	
	Quit ret
]]></Implementation>
</Method>

<Method name="SignalTask">
<Description><![CDATA[
Signals the completion of a task.
<p><var>pStatusCode</p> is the return status of the method, which processed the task.</p>
<p><var>pDebugMode</p> shows, whether the <class>Net.MQTT.Auxiliary.TaskList</class> object has to be kept for debugging purposes,
 or can be deleted.</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pConnectionId:%String,pTaskId:%String,pStatusCode:%Status,pDebugMode:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do $System.Event.Signal("^MQTT.Task(""" _ pConnectionId _ """,""" _ pTaskId _ """)", $Select($$$ISOK(pStatusCode): "", 1: $System.Status.GetErrorText(pStatusCode)))
	Set tSC = ..CompleteTask(pTaskId, pDebugMode)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="CreateNewTask">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pConnectionId:%String,pContextId:%String,pAction:%String,&pSC:%Status]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set obj = ..%New()
	Set obj.ConnectionId = pConnectionId
	Set obj.ContextId = pContextId
	Set obj.Action = pAction
	Set pSC = obj.%Save()
	Quit $Select($$$ISOK(pSC): obj.%Id(), 1: "")
]]></Implementation>
</Method>

<Method name="AcquireNext">
<ClassMethod>1</ClassMethod>
<FormalSpec>pConnectionId:%String,*pTaskId:%String,*pContextId:%String,*pAction:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set (pTaskId, pContextId, pAction) = ""
	Lock +^Net.MQTT.Auxiliary.TaskListD:5 Quit:('$Test) $$$ERROR($$$GeneralError, "Task table lock failed")
	TRY {
		&sql(SELECT TOP 1 
			ID, ContextId, Action 
		INTO 
			:pTaskId, :pContextId, :pAction
		FROM
			Net_MQTT_Auxiliary.TaskList
		WHERE
			ConnectionId = :pConnectionId AND Status = 0
		)
		If $Get(SQLCODE, 0) {
			If (SQLCODE '= 100) {
				Set tSC = $$$ERROR($$$GeneralError, "Task table query failed (" _ SQLCODE _ ")")
			}
		}
		Else {
			Set tSC = ..AcquireTask(pTaskId)
		}
	}
	CATCH ex {
		Set tSC = ex.AsStatus()
	}
	Lock -^Net.MQTT.Auxiliary.TaskListD
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="AcquireTask">
<ClassMethod>1</ClassMethod>
<FormalSpec>pTaskId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set obj = ..%OpenId(pTaskId, 4)
	If $IsObject(obj) {
		Set obj.Status = 1
		Set tSC = obj.%Save()
	}
	Else {
		Set tSC = $$$ERROR($$$GeneralError, "Task cannot be found (id = " _ pTaskId _ ")")
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="CompleteTask">
<ClassMethod>1</ClassMethod>
<FormalSpec>pTaskId:%String,pKeepIt:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK, found = 0
	If pKeepIt {
		Set obj = ..%OpenId(pTaskId, 4)
		If $IsObject(obj) {
			Set found = 1
			Set obj.Status = 2
			Set tSC = obj.%Save()
		}
	}
	Else {
		Set found = $$$ISOK(..%DeleteId(pTaskId, 4))
	}

	If 'found {
		Set tSC = $$$ERROR($$$GeneralError, "Task cannot be found (id = " _ pTaskId _ ")")
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Net.MQTT.Auxiliary.TaskListD</DataLocation>
<DefaultData>TaskListDefaultData</DefaultData>
<IdLocation>^Net.MQTT.Auxiliary.TaskListD</IdLocation>
<IndexLocation>^Net.MQTT.Auxiliary.TaskListI</IndexLocation>
<StreamLocation>^Net.MQTT.Auxiliary.TaskListS</StreamLocation>
<Data name="TaskListDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ConnectionId</Value>
</Value>
<Value name="3">
<Value>ContextId</Value>
</Value>
<Value name="4">
<Value>Action</Value>
</Value>
<Value name="5">
<Value>Status</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Net.MQTT.BMClient">
<TimeChanged>64243,73548.897776</TimeChanged>
<TimeCreated>64119,43072.612014</TimeCreated>

<Method name="MyMessageHandler">
<ClassMethod>1</ClassMethod>
<FormalSpec>pMessage:Net.MQTT.Message,pTopic:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
		set jstring = pMessage.Content
		set ^msg2($increment(^msg2)) = jstring
		set newObject = ##class(%DynamicAbstractObject).%fromJSON(jstring)
		
		for i=0:1:(newObject.%size() - 1) 
		{
			set item = newObject.%get(i)
			set s = ##class(Net.MQTT.Storage).%New()
			set s.DeviceID = $Piece(pTopic, "/isctest/client/", 2)
			set s.CreatedAt = item.createdAt
			set s.SensorType = item.name
			set s.Value1 = item.values.%get(0)
			set s.Value2 = item.values.%get(1)
			set s.Value3 = item.values.%get(2)
			set tSC =  s.%Save()
			if $$$ISOK(tSC) {
				do ##class(%DeepSee.Utils).%ProcessFact("SensorData", s.%Id(), 0)
			}
		}
	}
	CATCH ex {
		Set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="Net.MQTT.Client">
<Description><![CDATA[
The main class and public API for the <i>Caché Object Script</i> MQTT Client sample implementation (version: 0.9).

<p>For more information regarding the MQTT protocol visit the <a href="http://mqtt.org">MQTT Org.</a> website,
 or examine the <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html">OASIS</a> standard specification.</p>

<p>Fully functional to demonstrate all kind of MQTT Client activities, but not a fully-featured client.</p>

<p>There are a few known (and maybe some unknown) limitations:<ul>
<li>It's not prepared for SSL / TLS communication.</li>
<li>TCP/IP based only, cannot be used with web-socket based MQTT Brokers.</li>
<li>Communication of the <class>Net.MQTT.Client</class> and background <class>Net.MQTT.Agent</class> instances is limited to the
 tasks to be done / completed. This could be enriched with for example status information of the Agent, which would make
 it easier to monitor the background job from the Client interface and check its health status in certain scenarios.</li>
<li>Incoming and outgoing messages are simply logged into the <class>Net.MQTT.MessageStore</class> class. No any checks for
 duplicate messages are done (when an incoming message is repeated by the Broker, due to a lost acknowledge).</li>
<li>For incoming QoS Level 2 messages no retry mechanism is implemented: if no <b><var>PUBREL</b></var> message would arrive
 for the <b><var>PUBREC</b></var> acknowledge, the Agent will simply wait for it endless and the message remains in the 
 <class>Net.MQTT.Auxiliary.MessageStatus</class>, registered with a <var>waiting for PUBREL</var> status.</li>
</ul></p>
<p>Questions, bug reports, recommendations are highly welcome to my <a href="mailto:Attila.Toth@InterSystems.com">Inbox</a>.</p>]]></Description>
<IncludeCode>MQTTOptions</IncludeCode>
<Super>%Persistent,%XML.Adaptor</Super>
<TimeChanged>64251,55718</TimeChanged>
<TimeCreated>64041,57924.914604</TimeCreated>

<Property name="Host">
<Description>
Host name of the MQTT Broker.</Description>
<Type>%String</Type>
<InitialExpression>"localhost"</InitialExpression>
</Property>

<Property name="Port">
<Description>
Port number of the MQTT Broker.</Description>
<Type>%String</Type>
<InitialExpression>1883</InitialExpression>
</Property>

<Property name="SSLConfig">
<Description>
SSL/TLS Configuration to be used to build a secured TCP Connection to the MQTT Broker.</Description>
<Type>%String</Type>
</Property>

<Property name="ConnectTimeout">
<Description>
Timeout (in seconds) of building the TCP Connection to the MQTT Broker.</Description>
<Type>%Integer</Type>
<InitialExpression>10</InitialExpression>
</Property>

<Property name="ReadTimeout">
<Description><![CDATA[
Generic default timeout for all kinds of action when either an incoming TCP communication is expected,
 or the Client interface has to wait for the <class>Net.MQTT.Agent</class> to complete a task.]]></Description>
<Type>%Integer</Type>
<InitialExpression>10</InitialExpression>
</Property>

<Property name="KeepAliveInterval">
<Description><![CDATA[
The MQTT Broker may close the connection to the Client, if no requests are received within this interval (in seconds).
<p>It's the responsibility of the <class>Net.MQTT.Agent</class> to send a PING request at least in each intervals.</p>]]></Description>
<Type>%Integer</Type>
<InitialExpression>60</InitialExpression>
</Property>

<Property name="ClientId">
<Description><![CDATA[
Identifies the Client at the MQTT Broker.
<p>This implementation is restricted multiple places to use unique Client IDs among the co-existing <class>Net.MQTT.Client</class>
 instances within the same database. This restriction is acceptable, as the MQTT Brokers may reject multiple TCP connections 
 with the same Client ID.</p>]]></Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="23"/>
</Property>

<Property name="CleanSession">
<Description><![CDATA[
Sent with the <b><var>CONNECT</b></var> message to the MQTT Broker.
<p>For details see the MQTT standard specification.</p>]]></Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="LastWill">
<Description>
This object contains details of the "Last will and testament" of this Client - the message to be sent to subscribed Clients
 from the MQTT Broker in case, when the Broker's connection to this Client would be closed / lost.</Description>
<Type>Net.MQTT.Message</Type>
</Property>

<Property name="Retry">
<Description><![CDATA[
Some QoS Level 1 and 2 messages (<b><var>PUBLISH</b></var>, <b><var>PUBREL</b></var>, <b><var>SUBSCRIBE</b></var>, <b><var>UNSUBSCIBE</b></var>)
 might be re-sent by the Client if no appropriate acknowledge can be received from the MQTT Broker within the specified timout intervals.
<br/>This property controls the maximum number of repeated attempts.]]></Description>
<Type>%Integer</Type>
<InitialExpression>2</InitialExpression>
</Property>

<Property name="RetryInterval">
<Description><![CDATA[
Some QoS Level 1 and 2 messages (<b><var>PUBLISH</b></var>, <b><var>PUBREL</b></var>, <b><var>SUBSCRIBE</b></var>, <b><var>UNSUBSCIBE</b></var>)
 might be re-sent by the Client if no appropriate acknowledge can be received from the MQTT Broker within the specified timout intervals.
<br/>This property controls the wait interval (in seconds) within each repeated attempts.]]></Description>
<Type>%Integer</Type>
<InitialExpression>2</InitialExpression>
</Property>

<Property name="OnMessage">
<Description><![CDATA[
User-defined method, which is called whenever the <class>Net.MQTT.Agent</class> receives an incoming message.
<p>The required format of the <property>OnMessage</property> property is: <var>Classname:MethodName</var>. 
A sample implementation is provided in the <class>Net.MQTT.MessageHandler</class>.</p>

<p>If this property is empty, doesn't contain a valid classname/method name or the message handler method throws a runtime error,
that event is logged in the <property>traceTarget</property> (if it's set).</p>]]></Description>
<Type>%String</Type>
<InitialExpression>"Net.MQTT.MessageHandler:OnMessage"</InitialExpression>
</Property>

<Property name="traceTarget">
<Description>
For debugging purposes this property can be set to any global variable names (e.g.: ^MQTT.Trace), 
 in which case detailed trace information is logged into the specified global about the actions taken and also
 the incoming and outgoing TCP communication.</Description>
<Type>%String</Type>
</Property>

<Property name="trace">
<Type>%Boolean</Type>
<Calculated>1</Calculated>
</Property>

<Method name="traceGet">
<CodeMode>expression</CodeMode>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[..traceTarget '= ""
]]></Implementation>
</Method>

<Property name="traceLevel">
<Description><![CDATA[
The following settings are available to influence the content to be traced in the <property>traceTarget</property>:<ul>
<li><var>0</var> - no trace information</li>
<li><var>1</var> - errors only</li>
<li><var>2</var> - errors and warnings</li>
<li><var>3</var> - beyond errors and warnings, information about the actions made by the MQTT Client and Agent</li>
<li><var>4</var> - in this case even some originally temporary information is not deleted from auxiliary tables (e.g.: <class>Net.MQTT.Auxiliary.TaskList</li>
</ul> ]]></Description>
<Type>%Integer</Type>
<InitialExpression>3</InitialExpression>
<Required>1</Required>
<Parameter name="DISPLAYLIST" value=",notrace,error,warning,info,debug"/>
<Parameter name="VALUELIST" value=",0,1,2,3,4"/>
</Property>

<Property name="debugMode">
<Description><![CDATA[
<b>*** DEPRECATED ***:</b> Use <property>traceLevel</property> instead.
For debugging purposes this property can be set to 1, in which case some originally temporary information is not deleted from
 auxiliary tables (for example: <class>Net.MQTT.Auxiliary.TaskList</class>). ]]></Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="connectionId">
<Description><![CDATA[
This property is a unique identifier of the <class>Net.MQTT.Client</class> and the related <class>Net.MQTT.Agent</class> instance,
 and it is used in event-driven communication of the foreground Client and the background Agent processes.
<p>This is meant to be set automatically by the Client, do not set it directly!</p>]]></Description>
<Type>%String</Type>
<InitialExpression>$System.Util.CreateGUID()</InitialExpression>
</Property>

<Property name="agent">
<Description><![CDATA[
Do not manipulate this property, which should always contain the JOB id of the corresponding <class>Net.MQTT.Agent</class>.]]></Description>
<Type>%String</Type>
</Property>

<Method name="StartAgent">
<Description><![CDATA[
This is the first method to be called, in order to communicate with an MQTT Broker.
<p>Starts a <class>Net.MQTT.Agent</class> instance, which is responsible for building the TCP connection and 
 managing the communication with the broker.</p>]]></Description>
<FormalSpec>pUsername:%String="",pPassword:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	If ..agent '= "" {
		Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent to <" _ ..Host _ ":" _ ..Port _ "> has already been started")
	}
	Else {
		Set tSC = ##class(Net.MQTT.Auxiliary.MessageCounter).CreateCounter(..ClientId)
		Set:$$$ISOK(tSC) tSC = ..XMLExportToString(.data, "root")
		If $$$ISOK(tSC) {
			Do $System.Event.Create("^MQTT.Connect(""" _ ..connectionId _ """)")
			JOB ##class(Net.MQTT.Agent).StartListening(data, pUsername, pPassword)
			Set ..agent = $ZChild
			Set ret = $System.Event.WaitMsg("^MQTT.Connect(""" _ ..connectionId _ """)", (..ConnectTimeout * 1.5))
			If $ListGet(ret, 1) < 1 {
				Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent has not connected within the timeout period")
			}
			ElseIf $ListGet(ret, 2) '= "" {
				Set tSC = $$$ERROR($$$GeneralError, $ListGet(ret, 2))
			}
			
			If $$$ISERR(tSC) {
				Do ..KillAgent()
			}
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="StopAgent">
<Description><![CDATA[
Stops the Agent by sending <b><var>DISCONNECT</var></b> message and closing the TCP connection to the MQTT Broker.
<p>If this method completes successfully, the <class>Net.MQTT.Client</class> instance is re-usable and 
 its <method>StartAgent</method> method can be called again.</p>]]></Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	If ..agent '= "" {
		Set ret = ##class(Net.MQTT.Auxiliary.TaskList).WaitTask(..connectionId, ..connectionId, "DISCONNECT", ..ConnectTimeout * 1.5, .tSC)
		If $$$ISOK(tSC) {
			If $ListGet(ret, 1) < 1 {
				Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent has not disconnected within the timeout period")
			}
			ElseIf $ListGet(ret, 2) '= "" {
				Set tSC = $$$ERROR($$$GeneralError, $ListGet(ret, 2))
			}
		}
		
		Set tSC = $System.Status.AppendStatus(tSC, ..KillAgent())
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="KillAgent">
<Description><![CDATA[
Normally this meant to be used only internally by the <method>StopAgent</method> method.
<p>In some rare cases, when the Agent cannot be stopped normally (by sending a <b><var>DISCONNECT</var></b> message),
 this can still be used to terminate the Agent's background job and perform important maintenance steps.</p>]]></Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	If ..agent '= "" {
		Set ret = ##class(%SYSTEM.Process).Terminate(..agent, 0)
		If ret '= 1 {
			Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent cannot be stopped in a clean way (status = " _ ret _ ")")
		}
		Set ..agent = ""
	}
	Set tSC = $System.Status.AppendStatus(tSC, ##class(Net.MQTT.Auxiliary.MessageCounter).DropCounter(..ClientId))

	// Re-initialize connection id for subsequent start of the Agent
	Set ..connectionId = $System.Util.CreateGUID()

	Quit tSC
]]></Implementation>
</Method>

<Method name="Subscribe">
<Description><![CDATA[
Sends a request to the MQTT Broker to subsribe this client for a list of topics and controls the message flow:
<blockquote>
 Sends the <b><var>SUBSCRIBE</var></b> message and if no <b><var>SUBACK</var></b> has been received in the timeout period,
  it can retry the <b><var>SUBSCRIBE</var></b> according to the <property>Retry</property> and <property>RetryInterval</property> settings,
  before giving up and returning with an error.
</blockquote>
<blockquote>
 If the acknowledge is received, the <property>GrantedQoS</property> of each elements in the <var>pTopics</var> list should contain
  the QoS Level assured by the MQTT broker for the corresponding topic. 
</blockquote>
<p>Usage example:</p>
<example>
Set tpc = ##class(Net.MQTT.Message).%New()
Set tpc.Topic = "$SYS/broker/load/bytes/#"
Set tpc.QoSLevel = 2
Set topics = ##class(%ListOfObjects).%New()
Do topics.Insert(tpc)
 
Set client = ##class(Net.MQTT.Client).%New()
Set client.Host = "test.mosquitto.org"
Set client.ClientId = "My1stMQTTClient"
Set client.traceTarget = "^MQTT.Trace"
Set sc = client.StartAgent() If ('sc) { Do $System.OBJ.DisplayError(sc) }
Set sc = client.Subscribe(.topics) If ('sc) { Do $System.OBJ.DisplayError(sc) }
If (''sc) { Set t=topics.GetAt(1) Write "Topic:'"_t.Topic_"'; Expected QoS:"_t.QoSLevel_"; Granted QoS:"_t.GrantedQoS_";", ! }
; wait a few seconds to receive some messages from the broker 
Set sc = client.Unsubscribe(.topics) If ('sc) { Do $System.OBJ.DisplayError(sc) }
Set sc = client.StopAgent() If ('sc) { Do $System.OBJ.DisplayError(sc) }
ZWrite ^MQTT.Trace
</example>]]></Description>
<FormalSpec><![CDATA[&pTopics:%ListOfObjects(ELEMENTTYPE="Net.MQTT.Message")]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#dim sub As Net.MQTT.Auxiliary.Subscription
	If ..agent = "" {
		Quit $$$ERROR($$$GeneralError, "MQTT Agent to <" _ ..Host _ ":" _ ..Port _ "> has not been started yet")
	}
	If '$IsObject(pTopics) || (pTopics.Count() < 1) {
		Quit $$$ERROR($$$GeneralError, "At least one topic must be specified to subscribe for")
	}
	
	Set msgId = ##class(Net.MQTT.Auxiliary.MessageCounter).NextMessageId(..ClientId, .tSC)
	If $$$ISERR(tSC) {
		$$$MQTTTraceERR($System.Status.GetErrorText(tSC))
		Quit $$$ERROR($$$GeneralError, "Message ID for SUBSCRIBE message cannot be created")
	}
	
	TStart
	TRY {
		Set key = "", cnt = 0
		Set sub = ##class(Net.MQTT.Auxiliary.Subscription).CreateSubscription(..ClientId, msgId, .tSC)
		While $$$ISOK(tSC) {
			Set topic = pTopics.GetNext(.key) Quit:(key = "")
			Set tSC = sub.AddTopic(topic)
		}
	}
	CATCH ex {
		Set tSC = ex.AsStatus()
	}
	If $$$ISOK(tSC) { TCommit }
	Else { TRollback }
	
	Set retry = ..Retry, retcnt = 0, success = 0
	While $$$ISOK(tSC) && (success '= 1) {
		Set ret = ##class(Net.MQTT.Auxiliary.TaskList).WaitTask(..connectionId, msgId _ $Select(retcnt: ":" _ retcnt, 1: ""), "SUBSCRIBE", ..ReadTimeout, .tSC)
		If $$$ISOK(tSC) {
			If $ListGet(ret, 1) < 1 {
				Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent has not succeeded within the timeout period (" _ $ListGet(ret, 1) _ ")")
			}
			ElseIf $ListGet(ret, 2) '= "" {
				Set tSC = $$$ERROR($$$GeneralError, $ListGet(ret, 2))
			}
			Else {
				Set ack = ##class(Net.MQTT.Auxiliary.TaskList).WaitAck(..connectionId, msgId, "SUBACK", ..ReadTimeout)
				Set success  = $ListGet(ack, 1)
				If (success = 0) && (retry > 0) {
					$$$MQTTTraceERR("MQTT Agent has not received acknowledge within the timeout period (remaining reties: " _ retry _ ")")
					Hang ..RetryInterval
					Set retry = retry - 1, retcnt = retcnt + 1
				}
				ElseIf success < 1 {
					Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent has not received acknowledge within the timeout period (" _ success _ ")")
				}
				ElseIf $ListGet(ack, 2) '= "" {
					Set tSC = $$$ERROR($$$GeneralError, $ListGet(ack, 2))
				}
				Else {
					Set tSC = sub.RetrieveAck(.pTopics)
				}
			}
		}
	}
	
	If $IsObject(sub) {
		Set subid = sub.%Id(), sub = ""
		Set tSC = $System.Status.AppendStatus(tSC, ##class(Net.MQTT.Auxiliary.Subscription).DropSubscription(subid))
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="Unsubscribe">
<Description><![CDATA[
Sends a request to the MQTT Broker to unsubsribe this client from a list of topics and controls the message flow:
<blockquote>
 Sends the <b><var>UNSUBSCRIBE</var></b> message and if no <b><var>UNSUBACK</var></b> has been received in the timeout period,
  it can retry the <b><var>UNSUBSCRIBE</var></b> according to the <property>Retry</property> and <property>RetryInterval</property> settings,
  before giving up and returning with an error.
</blockquote>
<p>For usage example see the <method>Subscribe</method> method.</p>]]></Description>
<FormalSpec><![CDATA[&pTopics:%ListOfObjects(ELEMENTTYPE="Net.MQTT.Message")]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#dim sub As Net.MQTT.Auxiliary.Subscription
	If ..agent = "" {
		Quit $$$ERROR($$$GeneralError, "MQTT Agent to <" _ ..Host _ ":" _ ..Port _ "> has not been started yet")
	}
	If '$IsObject(pTopics) || (pTopics.Count() < 1) {
		Quit $$$ERROR($$$GeneralError, "At least one topic must be specified to unsubscribe from")
	}
	
	Set msgId = ##class(Net.MQTT.Auxiliary.MessageCounter).NextMessageId(..ClientId, .tSC)
	If $$$ISERR(tSC) {
		$$$MQTTTraceERR($System.Status.GetErrorText(tSC))
		Quit $$$ERROR($$$GeneralError, "Message ID for UNSUBSCRIBE message cannot be created")
	}
	
	TStart
	TRY {
		Set key = "", cnt = 0
		Set sub = ##class(Net.MQTT.Auxiliary.Subscription).CreateSubscription(..ClientId, msgId, .tSC)
		While $$$ISOK(tSC) {
			Set topic = pTopics.GetNext(.key) Quit:(key = "")
			Set tSC = sub.AddTopic(topic)
		}
	}
	CATCH ex {
		Set tSC = ex.AsStatus()
	}
	If $$$ISOK(tSC) { TCommit }
	Else { TRollback }
	
	Set retry = ..Retry, retcnt = 0, success = 0
	While $$$ISOK(tSC) && (success '= 1) {
		Set ret = ##class(Net.MQTT.Auxiliary.TaskList).WaitTask(..connectionId, msgId _ $Select(retcnt: ":" _ retcnt, 1: ""), "UNSUBSCRIBE", ..ReadTimeout, .tSC)
		If $$$ISOK(tSC) {
			If $ListGet(ret, 1) < 1 {
				Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent has not succeeded within the timeout period (" _ $ListGet(ret, 1) _ ")")
			}
			ElseIf $ListGet(ret, 2) '= "" {
				Set tSC = $$$ERROR($$$GeneralError, $ListGet(ret, 2))
			}
			Else {
				Set ack = ##class(Net.MQTT.Auxiliary.TaskList).WaitAck(..connectionId, msgId, "UNSUBACK", ..ReadTimeout)
				Set success  = $ListGet(ack, 1)
				If (success = 0) && (retry > 0) {
					$$$MQTTTraceERR("MQTT Agent has not received acknowledge within the timeout period (remaining reties: " _ retry _ ")")
					Hang ..RetryInterval
					Set retry = retry - 1, retcnt = retcnt + 1
				}
				If success < 1 {
					Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent has not received acknowledge within the timeout period (" _ success _ ")")
				}
				ElseIf $ListGet(ack, 2) '= "" {
					Set tSC = $$$ERROR($$$GeneralError, $ListGet(ack, 2))
				}
			}
		}
	}
	
	If $IsObject(sub) {
		Set subid = sub.%Id(), sub = ""
		Set tSC = $System.Status.AppendStatus(tSC, ##class(Net.MQTT.Auxiliary.Subscription).DropSubscription(subid))
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="Publish">
<Description><![CDATA[
Publishes a message to the MQTT Broker and (on QoS Level > 0) controls the message flow.
<p>In case of QoS = 1</p>
<blockquote>
 Sends the <b><var>PUBLISH</var></b> message and if no <b><var>PUBACK</var></b> has been received in the timeout period,
  it can retry the <b><var>PUBLISH</var></b> according to the <property>Retry</property> and <property>RetryInterval</property> settings,
  before giving up and returning with an error.
</blockquote>
<p>In case of QoS = 2</p>
<blockquote>
 Sends the <b><var>PUBLISH</var></b> message and if no <b><var>PUBREC</var></b> has been received in the timeout period,
  it can retry the <b><var>PUBLISH</var></b> according to the <property>Retry</property> and <property>RetryInterval</property> settings,
  before giving up and returning with an error.
</blockquote>
<blockquote>
 After the <b><var>PUBREC</var></b> message has been received, it sends the <b><var>PUBREL</var></b> message 
  and if no <b><var>PUBCOMP</var></b> has been received in the timeout period,
  it can retry the <b><var>PUBREL</var></b> according to the <property>Retry</property> and <property>RetryInterval</property> settings,
  before giving up and returning with an error.
</blockquote>
<p>Usage example:</p>
<example>
Set message = ##class(Net.MQTT.Message).%New()
Set message.Topic = "/isctest/client/sent"
Set message.Content = 1
Set message.QoSLevel = 2
 
Set client = ##class(Net.MQTT.Client).%New()
Set client.Host = "test.mosquitto.org"
Set client.ClientId = "My1stMQTTClient"
Set client.traceTarget = "^MQTT.Trace"
Set sc = client.StartAgent() If ('sc) { Do $System.OBJ.DisplayError(sc) }
Set sc = client.Publish(message) If ('sc) { Do $System.OBJ.DisplayError(sc) }
Set sc = client.StopAgent() If ('sc) { Do $System.OBJ.DisplayError(sc) }
ZWrite ^MQTT.Trace
</example>]]></Description>
<FormalSpec>pMessage:Net.MQTT.Message</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If ..agent = "" {
		Quit $$$ERROR($$$GeneralError, "MQTT Agent to <" _ ..Host _ ":" _ ..Port _ "> has not been started yet")
	}
	If '$IsObject(pMessage) {
		Quit $$$ERROR($$$GeneralError, "A message must be specified to publish")
	}
	
	Set tSC = $$$OK
	If pMessage.QoSLevel > 0 {
		Set pMessage.MessageId = ##class(Net.MQTT.Auxiliary.MessageCounter).NextMessageId(..ClientId, .tSC)
		Set:$$$ISOK(tSC) tSC = ##class(Net.MQTT.Auxiliary.MessageStatus).RegisterMessageOut(..ClientId, pMessage.MessageId)
	}
	If $$$ISERR(tSC) {
		$$$MQTTTraceERR($System.Status.GetErrorText(tSC))
		Quit $$$ERROR($$$GeneralError, "Message ID for PUBLISH message cannot be created")
	}
	
	Set msg				= ##class(Net.MQTT.MessageStore).%New()
	Set msg.ClientId	= ..ClientId
	Set msg.Direction	= "O"
	Set msg.MessageId	= pMessage.MessageId
	Set msg.QoSLevel	= pMessage.QoSLevel
	Set msg.Retain		= pMessage.Retain
	Set msg.Topic		= pMessage.Topic
	Set msg.Content		= pMessage.Content
	Set tSC = msg.%Save()
	
	Set retry = ..Retry, retcnt = 0, success = 0
	Set acktype = $Case(pMessage.QoSLevel, 2: "PUBREC", 1: "PUBACK", : "")
	While $$$ISOK(tSC) && (success '= 1) {
		Set ret = ##class(Net.MQTT.Auxiliary.TaskList).WaitTask(..connectionId, msg.%Id() _ $Select(retcnt: ":" _ retcnt, 1: ""), "PUBLISH", ..ReadTimeout, .tSC)
		If $$$ISOK(tSC) {
			If $ListGet(ret, 1) < 1 {
				Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent has not succeeded within the timeout period (" _ $ListGet(ret, 1) _ ")")
			}
			ElseIf $ListGet(ret, 2) '= "" {
				Set tSC = $$$ERROR($$$GeneralError, $ListGet(ret, 2))
			}
			ElseIf pMessage.QoSLevel = 0 {
				Set success = 1
			}
			ElseIf pMessage.QoSLevel > 0 {
				Set ack = ##class(Net.MQTT.Auxiliary.TaskList).WaitAck(..connectionId, pMessage.MessageId, acktype, ..ReadTimeout)
				Set success  = $ListGet(ack, 1)
				If (success = 0) && (retry > 0) {
					$$$MQTTTraceERR("MQTT Agent has not received acknowledge within the timeout period (remaining reties: " _ retry _ ")")
					Hang ..RetryInterval
					Set retry = retry - 1, retcnt = retcnt + 1
				}
				If success < 1 {
					Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent has not received acknowledge within the timeout period (" _ success _ ")")
				}
				ElseIf $ListGet(ack, 2) '= "" {
					Set tSC = $$$ERROR($$$GeneralError, $ListGet(ack, 2))
				}
				ElseIf pMessage.QoSLevel = 2 {
					Set tSC = ..PublishQoS2(pMessage.MessageId)
				}
			}
		}
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="PublishQoS2">
<Description><![CDATA[
Internal method, used by <method>Publish</method> to manage the second pahse of QoS Level 2 message flow
(<b><var>PUBREL</var></b> message is sent and <b><var>PUBCOMP</var></b> is expected).]]></Description>
<Internal>1</Internal>
<FormalSpec>pMessageId:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	
	Set retry = ..Retry, retcnt = 0, success = 0
	While $$$ISOK(tSC) && (success '= 1) {
		Set ret = ##class(Net.MQTT.Auxiliary.TaskList).WaitTask(..connectionId, pMessageId _ $Select(retcnt: ":" _ retcnt, 1: ""), "PUBREL", ..ReadTimeout, .tSC)
		If $$$ISOK(tSC) {
			If $ListGet(ret, 1) < 1 {
				Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent has not sent QoS=2 acknowledge within the timeout period (" _ $ListGet(ret, 1) _ ")")
			}
			ElseIf $ListGet(ret, 2) '= "" {
				Set tSC = $$$ERROR($$$GeneralError, $ListGet(ret, 2))
			}
			Else {
				Set ack = ##class(Net.MQTT.Auxiliary.TaskList).WaitAck(..connectionId, pMessageId, "PUBCOMP", ..ReadTimeout)
				Set success  = $ListGet(ack, 1)
				If (success = 0) && (retry > 0) {
					$$$MQTTTraceERR("MQTT Agent has not received QOS=2 acknowledge within the timeout period (remaining reties: " _ retry _ ")")
					Hang ..RetryInterval
					Set retry = retry - 1, retcnt = retcnt + 1
				}
				If success < 1 {
					Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent has not received QOS=2 acknowledge within the timeout period (" _ success _ ")")
				}
				ElseIf $ListGet(ack, 2) '= "" {
					Set tSC = $$$ERROR($$$GeneralError, $ListGet(ack, 2))
				}
			}
		}
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetProtocolName">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..GetUTFString("MQIsdp")
]]></Implementation>
</Method>

<Method name="GetProtocolVersion">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$Char(3)
]]></Implementation>
</Method>

<Method name="GetUTFString">
<FormalSpec>pString:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ""
]]></Implementation>
</Method>

<Method name="ResetClient">
<Description><![CDATA[
For maintenance purposes only! <b>USE WITH CARE!</b>
<p>If one of the message flows would break with unexpected error, the <class>Net.MQTT.Client</class> may leave
 records behind in some auxiliary classes which can prevent the same <property>ClientId</property> to be used in a subsequent
 execution of a <class>Net.MQTT.Client</class> instance.</p>
<p>This auxiliary method is responsible for clearing those records when needed.</p>
<p><b>WARNING:</b> if this is called while a <class>Net.MQTT.Agent</class> with the same Client ID is still active,
 this may cause errors in the Agent, too. And stopping the Agent in a clear way (with sending a <b><var>DISCONNECT</var></b> message)
 won't be possible any more. Use <method>KillAgent</method> in this case!</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClientId:%String</FormalSpec>
<Implementation><![CDATA[
	Do ##class(Net.MQTT.Auxiliary.MessageCounter).%DeleteId(pClientId)
	&sql(DELETE FROM Net_MQTT_Auxiliary.Subscription WHERE ClientId = :pClientId)
	&sql(DELETE FROM Net_MQTT_Auxiliary.MessageStatus WHERE ClientId = :pClientId)
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Net.MQTT.ClientD</DataLocation>
<DefaultData>ClientDefaultData</DefaultData>
<IdLocation>^Net.MQTT.ClientD</IdLocation>
<IndexLocation>^Net.MQTT.ClientI</IndexLocation>
<StreamLocation>^Net.MQTT.ClientS</StreamLocation>
<Data name="ClientDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Host</Value>
</Value>
<Value name="3">
<Value>Port</Value>
</Value>
<Value name="4">
<Value>SSLConfig</Value>
</Value>
<Value name="5">
<Value>ConnectTimeout</Value>
</Value>
<Value name="6">
<Value>ReadTimeout</Value>
</Value>
<Value name="7">
<Value>KeepAliveInterval</Value>
</Value>
<Value name="8">
<Value>ClientId</Value>
</Value>
<Value name="9">
<Value>CleanSession</Value>
</Value>
<Value name="10">
<Value>LastWill</Value>
</Value>
<Value name="11">
<Value>Retry</Value>
</Value>
<Value name="12">
<Value>RetryInterval</Value>
</Value>
<Value name="13">
<Value>OnMessage</Value>
</Value>
<Value name="14">
<Value>traceTarget</Value>
</Value>
<Value name="15">
<Value>debugMode</Value>
</Value>
<Value name="16">
<Value>connectionId</Value>
</Value>
<Value name="17">
<Value>agent</Value>
</Value>
<Value name="18">
<Value>traceLevel</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Net.MQTT.Delayer">
<Super>%SerialObject</Super>
<TimeChanged>64243,73662.085876</TimeChanged>
<TimeCreated>64231,37233.143969</TimeCreated>

<Property name="ActiveDelay">
<Type>%Float</Type>
</Property>

<Method name="ActiveDelayGet">
<ReturnType>%Float</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit ""
]]></Implementation>
</Method>

<Method name="ActiveDelaySet">
<FormalSpec>Arg:%Float</FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Property name="PassiveDelay">
<Type>%Float</Type>
</Property>

<Method name="PassiveDelayGet">
<ReturnType>%Float</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit ""
]]></Implementation>
</Method>

<Method name="PassiveDelaySet">
<FormalSpec>Arg:%Float</FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Property name="IterationCount">
<Type>%Numeric</Type>
</Property>

<Method name="IterationCountGet">
<ReturnType>%Numeric</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit ""
]]></Implementation>
</Method>

<Method name="IterationCountSet">
<FormalSpec>Arg:%Numeric</FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Delay">
<FormalSpec>HasSignal:%Binary=TRUE</FormalSpec>
<Implementation><![CDATA[
	if (HasSignal = TRUE) {
		Set ..CurrentIteration = 0
		set ^msg2($increment(^msg2)) = 1
		Hang ..ActiveDelay
	} else {
		Set ..CurrentIteration = ..CurrentIteration + 1
		if (..CurrentIteration = ..IterationCount) {
			Hang ..PassiveDelay
			set ^msg2($increment(^msg2)) = 1
		}
	}
]]></Implementation>
</Method>

<Property name="CurrentIteration">
<Type>%Numeric</Type>
</Property>

<Storage name="Default">
<Type>%Library.CacheSerialState</Type>
<State>DelayerState</State>
<StreamLocation>^Net.MQTT.DelayerS</StreamLocation>
<Data name="DelayerState">
<Value name="1">
<Value>ActiveDelay</Value>
</Value>
<Value name="2">
<Value>PassiveDelay</Value>
</Value>
<Value name="3">
<Value>IterationCount</Value>
</Value>
<Value name="4">
<Value>CurrentIteration</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Net.MQTT.Message">
<Description><![CDATA[
This structure is used as the input / output parameter type of multiple <class>Net.MQTT.Client</clas> methods.]]></Description>
<Super>%RegisteredObject,%XML.Adaptor</Super>
<TimeChanged>64131,57977.885311</TimeChanged>
<TimeCreated>64043,42166.491302</TimeCreated>

<Property name="ClientId">
<Description><![CDATA[
In certain sitatuations the ClientId of the <class>Net.MQTT.Client</class> and <class>Net.MQTT.Agent</class> objects 
is also recorded in the Message object. Usually this property remains empty though. ]]></Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="23"/>
</Property>

<Property name="MessageId">
<Description>
Message Identifier. Usually it doesn't have to be set, when used as an input parameter. </Description>
<Type>%Integer</Type>
<Parameter name="MAXVAL" value="65535"/>
<Parameter name="MINVAL" value="1"/>
</Property>

<Property name="Topic">
<Type>%String</Type>
</Property>

<Property name="Content">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="QoSLevel">
<Description><![CDATA[
Quality of service, expected / provided by the client.<ul>
<li><b><var>0</var></b> - no guaranteed message delivery.</li>
<li><b><var>1</var></b> - at least once delivery (simple acknowledge).</li>
<li><b><var>2</var></b> - exactly once delivery (two level acknowledges).</li>
</ul>]]></Description>
<Type>%Integer</Type>
<Parameter name="VALUELIST" value=",0,1,2"/>
</Property>

<Property name="GrantedQoS">
<Description><![CDATA[
In case of subscriptions, this is the quality of service, provided by the server (may differ from the one expected by the client).
<br/>For details see <property>QoSLevel</property>]]></Description>
<Type>%Integer</Type>
<Parameter name="VALUELIST" value=",0,1,2"/>
</Property>

<Property name="Retain">
<Description>
In some message flows (publish, subscribe) may show, whether the server is expected to keep the message,
 even after the client disconnects.</Description>
<Type>%Boolean</Type>
</Property>
</Class>


<Class name="Net.MQTT.MessageHandler">
<Abstract>1</Abstract>
<TimeChanged>64138,59002.145789</TimeChanged>
<TimeCreated>64131,56764.693636</TimeCreated>

<Method name="OnMessage">
<Description><![CDATA[
Sample implementation of a message handler method, which is called by the <class>Net.MQTT.Agent</class> everytime, when it receives
a new incoming message.

The name of this class and method have to be set in the <property>OnMessage</property> property of the <class>Net.MQTT.Client</class> object.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pMessage:Net.MQTT.Message,pDublicate:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set msg				= ##class(Net.MQTT.MessageStore).%New()
	Set msg.ClientId	= pMessage.ClientId
	Set msg.Direction	= "I"
	Set msg.MessageId	= pMessage.MessageId
	Set msg.QoSLevel	= pMessage.QoSLevel
	Set msg.Retain		= pMessage.Retain
	Set msg.Topic		= pMessage.Topic
	Set msg.Content		= pMessage.Content

	Quit msg.%Save()
]]></Implementation>
</Method>
</Class>


<Class name="Net.MQTT.MessageStore">
<Description><![CDATA[
Sample message store for messages published by or recieved by <class>Net.MQTT.Client</class> and <class>Net.MQTT.Agent</class> instances.
<p>This could be implemented different ways. For example: this implementation does not care about duplicate messages.</p>
<p>In this sample MQTT Client implementation this class just stores all the incoming and outgoing messages unconditionally.</p>
<p>For more documentation of message properties see: <class>Net.MQTT.Message</class>.</p>]]></Description>
<Super>%Persistent</Super>
<TimeChanged>64072,57252.367978</TimeChanged>
<TimeCreated>64050,80453.857656</TimeCreated>

<Index name="MsgIdx">
<Properties>ClientId,Topic</Properties>
</Index>

<Property name="ClientId">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="23"/>
</Property>

<Property name="Topic">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Direction">
<Description><![CDATA[
Direction of the message: <b><var>I</var></b> is for <var>input</var> (subscribe), <b><var>O</var></b> is for <var>output</var> (publish). ]]></Description>
<Type>%String</Type>
<InitialExpression>"I"</InitialExpression>
<Required>1</Required>
<Parameter name="VALUELIST" value=",I,O"/>
</Property>

<Property name="MessageId">
<Type>%Integer</Type>
<Parameter name="MAXVAL" value="65653"/>
<Parameter name="MINVAL" value="1"/>
</Property>

<Property name="Content">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="QoSLevel">
<Type>%Integer</Type>
<Parameter name="VALUELIST" value=",0,1,2"/>
</Property>

<Property name="GrantedQoS">
<Type>%Integer</Type>
<Parameter name="VALUELIST" value=",0,1,2"/>
</Property>

<Property name="Retain">
<Type>%Boolean</Type>
</Property>

<Property name="CreatedAt">
<Type>%TimeStamp</Type>
<InitialExpression>$ZDateTime($ZTimestamp, 3)</InitialExpression>
<Required>1</Required>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Net.MQTT.MessageStoreD</DataLocation>
<DefaultData>MessageStoreDefaultData</DefaultData>
<IdLocation>^Net.MQTT.MessageStoreD</IdLocation>
<IndexLocation>^Net.MQTT.MessageStoreI</IndexLocation>
<StreamLocation>^Net.MQTT.MessageStoreS</StreamLocation>
<Data name="MessageStoreDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ClientId</Value>
</Value>
<Value name="3">
<Value>Topic</Value>
</Value>
<Value name="4">
<Value>MessageId</Value>
</Value>
<Value name="5">
<Value>Content</Value>
</Value>
<Value name="6">
<Value>QoSLevel</Value>
</Value>
<Value name="7">
<Value>GrantedQoS</Value>
</Value>
<Value name="8">
<Value>Retain</Value>
</Value>
<Value name="9">
<Value>CreatedAt</Value>
</Value>
<Value name="10">
<Value>Direction</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Net.MQTT.Parameters">
<Super>%RegisteredObject</Super>
<TimeChanged>64230,81203.829539</TimeChanged>
<TimeCreated>64230,81203.829539</TimeCreated>
</Class>


<Class name="Net.MQTT.Storage">
<Super>%Persistent,%Populate</Super>
<TimeChanged>64125,74040.342238</TimeChanged>
<TimeCreated>64120,39481.998143</TimeCreated>

<Property name="DeviceID">
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="SensorType">
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="CreatedAt">
<Type>%DateTime</Type>
<Required>1</Required>
</Property>

<Property name="Value1">
<Type>%Numeric</Type>
<Required>1</Required>
</Property>

<Property name="Value2">
<Type>%Numeric</Type>
<Required>1</Required>
</Property>

<Property name="Value3">
<Type>%Numeric</Type>
<Required>1</Required>
</Property>

<Parameter name="DSTIME">
<Default>MANUAL</Default>
</Parameter>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Net.MQTT.StorageD</DataLocation>
<DefaultData>StorageDefaultData</DefaultData>
<IdLocation>^Net.MQTT.StorageD</IdLocation>
<IndexLocation>^Net.MQTT.StorageI</IndexLocation>
<StreamLocation>^Net.MQTT.StorageS</StreamLocation>
<Data name="StorageDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>DeviceID</Value>
</Value>
<Value name="3">
<Value>SensorType</Value>
</Value>
<Value name="4">
<Value>CreatedAt</Value>
</Value>
<Value name="5">
<Value>Value1</Value>
</Value>
<Value name="6">
<Value>Value2</Value>
</Value>
<Value name="7">
<Value>Value3</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="REST.Broker">
<Super>%CSP.REST</Super>
<TimeChanged>64125,80876.72376</TimeChanged>
<TimeCreated>64118,50433.03431</TimeCreated>

<XData name="UrlMap">
<XMLNamespace>http://www.intersystems.com/urlmap</XMLNamespace>
<Data><![CDATA[
<Routes>

 <Route Url="/test" Method="GET" Call="Test" Cors="true"/>
 
 <Route Url="/json/connect/:ClientID" Method="GET" Call="REST.JSON:GetConnect" Cors="true"/>
 <Route Url="/json/disconnect/:ClientObjectID" Method="GET" Call="REST.JSON:GetDisconnect" Cors="true"/>
 <Route Url="/json/publish/:ClientObjectID" Method="POST" Call="REST.JSON:PostPublish" Cors="true"/>
 <Route Url="/json/subscribe/:ClientObjectID" Method="POST" Call="REST.JSON:PostSubscribe" Cors="true"/>
 <Route Url="/json/unsubscribe/:ClientObjectID" Method="POST" Call="REST.JSON:PostUnsubscribe" Cors="true"/>
 <Route Url="/json/messages" Method="GET" Call="REST.JSON:GetLastMessages" Cors="true"/>
 </Routes>
]]></Data>
</XData>

<Method name="Test">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    &html<Работает!>
    quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="REST.Callback">
<Description>
This class contains all the callback methods</Description>
<Super>%Persistent</Super>
<TimeChanged>64243,83992.630194</TimeChanged>
<TimeCreated>64231,50354.351519</TimeCreated>

<Method name="LightSwitch">
<ClassMethod>1</ClassMethod>
<FormalSpec>LightId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^REST.CallbackD</DataLocation>
<DefaultData>CallbackDefaultData</DefaultData>
<IdLocation>^REST.CallbackD</IdLocation>
<IndexLocation>^REST.CallbackI</IndexLocation>
<StreamLocation>^REST.CallbackS</StreamLocation>
<Data name="CallbackDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="REST.JSON">
<Super>%Base</Super>
<TimeChanged>64125,78345.70136</TimeChanged>
<TimeCreated>64118,52495.950387</TimeCreated>

<Parameter name="TRACETARGET">
<Type>%String</Type>
<Default>^MQTT.Trace</Default>
</Parameter>

<Parameter name="ONMESSAGE">
<Type>%String</Type>
<Default>Net.MQTT.BMClient:MyMessageHandler</Default>
</Parameter>

<Method name="GetConnect">
<ClassMethod>1</ClassMethod>
<FormalSpec>ClientID:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set status=$$$OK
	// Definition of dynamic json object
	set object = ##class(%Object).$new()
   try { 
   
   // Defining and saving the client
   set client = ##class(Net.MQTT.Client).%New()
   set client.Host = "iot.eclipse.org"
   set client.ClientId = ClientID
   set client.traceTarget = ..#TRACETARGET
   set client.OnMessage = ..#ONMESSAGE
   If $$$ISOK(status) {
    // Starting the agent
   	set status = client.StartAgent() 
   }
   set status = client.%Save()
 
   // Producement of a JSON (success)
   If $$$ISOK(status) {
    do object.$set("success", 1, "boolean")
    set object.clientObject = client.%Id()
   }
	   }
	   catch ex {
	   set status = ex.AsStatus()	
	   }
	   // Producement of a JSON (fail)
	   if $$$ISERR(status) 
	   {
  		do object.$set("success", 0, "boolean")
  		Set object.error = $System.Status.GetErrorText(status)
  		}
	write object.$toJSON()
	quit $$$OK
]]></Implementation>
</Method>

<Method name="GetDisconnect">
<ClassMethod>1</ClassMethod>
<FormalSpec>ClientObjectID:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set status=$$$OK
	// Definition of dynamic json object
	set object = ##class(%Object).$new()
   try { 
   
   // Opening a client from DB and stopping the agent
   set client = ##class(Net.MQTT.Client).%OpenId(ClientObjectID, -1, .st)
   set status = client.StopAgent()
   // Producement of a JSON (fail)
   If $$$ISERR(status) {
   	do object.$set("success", 0, "boolean")
   	Set object.error = $System.Status.GetErrorText(status)
   }
   
   // Deleting a client
   set status = ##class(Net.MQTT.Client).%DeleteId(ClientObjectID)
  
   // Producement of a JSON (success)
   If $$$ISOK(status) {
    do object.$set("success", 1, "boolean")
   }
   		} 
   		catch ex {
	   	set status=ex.AsStatus()
	   	}
	   	// Producement of a JSON (fail)
	   	if $$$ISERR(status) {
  		do object.$set("success", 0, "boolean")
 		Set object.error = $System.Status.GetErrorText(st)
	  	}
	write object.$toJSON()
	quit $$$OK
]]></Implementation>
</Method>

<Method name="PostSubscribe">
<ClassMethod>1</ClassMethod>
<FormalSpec>ClientObjectID:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set status=$$$OK
	// Definition of dynamic json object
	set object = ##class(%Object).$new()
   try {
   
   // Getting content data
   set obj = %request.Content.Read($$$MaxStringLength)
   
   // Opening a client from DB
   set client = ##class(Net.MQTT.Client).%OpenId(ClientObjectID, -1, .status)
   // Producement of a JSON (fail)
   if $$$ISERR(status) {
	   do object.$set("success", 0, "boolean")
	   Set object.error = $System.Status.GetErrorText(status)
	   }
   
   // Defining mqtt message class and list of mqtt objects
   Set tpc = ##class(Net.MQTT.Message).%New()
   Set topics = ##class(%ListOfObjects).%New()
   
   // Creation of an abstract object and a subscription
   set JSON = ##class(%AbstractObject).$fromJSON(obj)
   for x=0:1:(JSON.$size()-1){
	   set tpc.Topic = JSON.$get(x).topicFilter
	   set tpc.QoSLevel = JSON.$get(x).qos
	   Do topics.Insert(tpc)
	   }
	   set status = client.Subscribe(.topics)
	   // Producement of a JSON (fail)
	   if $$$ISERR(status) {
  		do object.$set("success", 0, "boolean")
  		Set object.error = $System.Status.GetErrorText(status)
	  	}

   set topicArray = ##class(%Array).$new()
   //Making topics list parseable to JSON
   for x=1:1:(topics.Count()){
	   set topicget = topics.GetAt(x)
	   set topicobject = ##class(%Object).$new()
	   set topicobject.topicFilter = topicget.Topic
	   set topicobject.qos = topicget.QoSLevel
	   do topicArray.$push(topicobject)
	   }
   // Producement of a JSON (success)
   If $$$ISOK(status) {
    do object.$set("success", 1, "boolean")
   }
   set object.topics = topicArray
  
 
   		} catch ex {
       	set status=ex.AsStatus()
       	}
	   	if $$$ISERR(status) {
  		// Creation of dynamic object and producement of a JSON (fail)
  		do object.$set("success", 0, "boolean")
  		Set object.error = $System.Status.GetErrorText(status)
		}
	// Producement of a JSON (success)
	write object.$toJSON()
	quit $$$OK
]]></Implementation>
</Method>

<Method name="PostUnsubscribe">
<ClassMethod>1</ClassMethod>
<FormalSpec>ClientObjectID:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set status=$$$OK
	// Definition of dynamic json object
	set object = ##class(%Object).$new()
   try { 
   
   // Getting content data
   set obj = %request.Content.Read($$$MaxStringLength)
   
   // Opening a client from DB
   set client = ##class(Net.MQTT.Client).%OpenId(ClientObjectID, -1, .status)
   If $$$ISERR(status) {
   	do object.$set("success", 0, "boolean")
   	Set object.error = $System.Status.GetErrorText(status)
   }
   
   // Defining mqtt message class and list of mqtt objects
   Set tpc = ##class(Net.MQTT.Message).%New()
   Set topics = ##class(%ListOfObjects).%New()
   
   // Producement of a JSON
   set JSON = ##class(%AbstractObject).$fromJSON(obj)
   for x=0:1:(JSON.$size()-1){
	   set tpc.Topic = JSON.$get(x).topicFilter
	   Do topics.Insert(tpc)
	   }
	   set status = client.Unsubscribe(.topics)
	   // Producement of a JSON (success)
   		If $$$ISOK(status) {
    	do object.$set("success", 1, "boolean")
   		}
	   // Producement of a JSON (fail)
	   if $$$ISERR(status) {
  		do object.$set("success", 0, "boolean")
  		Set object.error = $System.Status.GetErrorText(status)
       }
   
  } catch ex {
       set status=ex.AsStatus()
       // Producement of a JSON (fail)
       if $$$ISERR(status) {
  		do object.$set("success", 0, "boolean")
  		Set object.error = $System.Status.GetErrorText(status)
       }
	}
	// Producement of a JSON (success)
	write object.$toJSON()
	quit $$$OK
]]></Implementation>
</Method>

<Method name="PostPublish">
<ClassMethod>1</ClassMethod>
<FormalSpec>ClientObjectID:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set status=$$$OK
	// Definition of dynamic json object
	set object = ##class(%Object).$new()
   try { 
   
   // Opening a client from DB and publishing a message
   set client = ##class(Net.MQTT.Client).%OpenId(ClientObjectID, -1, .status)
   
   // Getting content data
   set obj = %request.Content.Read($$$MaxStringLength)
   
   // Defining mqtt message class and list of mqtt objects
   Set message = ##class(Net.MQTT.Message).%New()
   
   // Creation of abstract object and producement of a JSON
   set JSON = ##class(%AbstractObject).$fromJSON(obj)
   
	   set message.Topic = JSON.topicName
	   set message.QoSLevel = JSON.qos
	   set message.Retain = JSON.retain
	   set message.Content = JSON.content
	   set status = client.Publish(message)
	   If $$$ISOK(status) {
    	do object.$set("success", 1, "boolean")
    	}
   	} catch ex {
       set status=ex.AsStatus()
       }
	// Producement of a JSON (fail)
    if $$$ISERR(status) {
  	do object.$set("success", 0, "boolean")
  	Set object.error = $System.Status.GetErrorText(status)
  	}
	write object.$toJSON()
	quit $$$OK
]]></Implementation>
</Method>

<Method name="GetLastMessages">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   set status=$$$OK
   // Definition of dynamic json object
   set object = ##class(%Object).$new()
   set queryArray = ##class(%Array).$new()
   set object.data = queryArray

   // Execution of the query
   #sqlcompile select = display
   TRY {
  	&sql(DECLARE c1 CURSOR FOR 
  	SELECT 
  	info.DeviceID AS device, info.SensorType AS sensor, info.CreatedAt AS created, 
  	info.Value1 AS val1, info.Value2 AS val2, info.Value3 AS val3
  	INTO :device, :sensor, :created, :value1, :value2, :value3
	FROM 
  	Net_MQTT.Storage AS info
	INNER JOIN
	( 
  	SELECT DeviceID, SensorType, MAX(ID) AS ID FROM Net_MQTT.Storage
  	GROUP BY DeviceID, SensorType
	) AS lastmsg
	ON info.ID = lastmsg.ID
	ORDER BY sensor, device
  	)
  	If '$Get(SQLCODE, 0) { &sql(OPEN c1) }
  	If $Get(SQLCODE, 0) { Set status = $$$ERROR($$$SQLError, SQLCODE, "Problem while opening 'c1'") }
  
  	While $$$ISOK(status) {
	  	&sql(FETCH c1) Quit:SQLCODE
	  	set record = ##class(%Object).$new()
	  	set record.device = device 
	  	set record.sensor = sensor
	  	set record.created = created
	  	set record.value1 = value1
	  	set record.value2 = value2
	  	set record.value3 = value3
	  	do queryArray.$push(record)
 	}
 	
 	If $$$ISOK(status) && $Get(SQLCODE, 0) && (SQLCODE '= 100) {
    	Set status = $$$ERROR($$$SQLError, SQLCODE, "Problem while fetching 'c1'")
    }
    Else {
		do object.$set("success", 1, "boolean")
	}
   }
 	CATCH ex {
  		Set status = ex.AsStatus()
	}
	if $$$ISERR(status) {
		do object.$set("success", 0, "boolean")
		set object.error = $System.Status.GetErrorText(status)
		set object.data = ##class(%Array).$new()
	}
	write object.$toJSON()
 	&sql(CLOSE c1)
 	Quit $$$OK
]]></Implementation>
</Method>
</Class>
</Export>
