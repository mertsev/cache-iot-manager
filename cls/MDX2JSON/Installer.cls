Class MDX2JSON.Installer
{

/// See generated code in zsetup+1^MDX2JSON.Installer.1
/// todo add optional parameter WEBAPP to Alter web app name if it needs to have another then namespace name
XData Install [ XMLNamespace = INSTALLER ]
{
<Manifest>
<IfNotDef Var="Namespace">
<Var Name="Namespace" Value="MDX2JSON"/>
<Log Text="Set namespace to ${Namespace}" Level="0"/>
</IfNotDef>

<!--<Role Name="MDX2JSON" Description="Role to access and use MDX2JSON API" Resources="%DB_CACHESYS:RW,%Admin_Secure:U" />-->

<If Condition='(##class(Config.Namespaces).Exists("${Namespace}")=0)'>
<Log Text="Creating namespace ${Namespace}" Level="0"/>
<Namespace Name="${Namespace}" Create="yes" Code="${Namespace}" Ensemble="" Data="${Namespace}">
<Configuration>
<Database Name="${Namespace}" Dir="${MGRDIR}/${Namespace}" Create="yes" MountRequired="true" Resource="%DB_${Namespace}" PublicPermissions="RW" MountAtStartup="true"/>
</Configuration>
</Namespace>
 <Log Text="End Creating namespace ${Namespace}" Level="0"/>
</If>

<Namespace Name="${Namespace}" Create="no">
<IfDef Var="SourceDir">
<Log Text="SourceDir defined - offline install from ${SourceDir}" Level="0"/>
<Import File="${SourceDir}"/>
</IfDef>
<IfNotDef Var="SourceDir">
<Log Text="SourceDir undefined - online install from GitHub" Level="0"/>
<RunInstall Class="MDX2JSON.Installer" Method="DownloadFromGitHub"/>
</IfNotDef>
<If Condition='(##class(Security.Applications).Exists("/"_"${Namespace}")=0)'>
	<Log Text="Creating web application /${Namespace}" Level="0"/>
	<!-- This method creates conflits with web-server. Kept for reference purposes. See ##class(%EnsembleMgr).createPortalApp()
	<CSPApplication Url="/${Namespace}" Directory="" AuthenticationMethods="64" IsNamespaceDefault="false" />-->
	<RunInstall Class="MDX2JSON.Installer" Method="CreateWebApp"/>
</If>
</Namespace>

<If Condition='(##class(Config.Namespaces).Exists("%All")=0)'>
<Log Text="Creating namespace %All" Level="0"/>
<Namespace Name="%All" Create="yes" Code="CACHETEMP" Data="CACHETEMP" Ensemble="0">
<Configuration>
	<Log Text="Mapping MDX2JSON package to %All namespace" Level="0"/>
	<ClassMapping From="${Namespace}" Package="MDX2JSON"/>
	<GlobalMapping From="${Namespace}" Global="MDX2JSON"/>
</Configuration>
</Namespace>
</If>

<Log Text="Mapping MDX2JSON package to Samples namespace" Level="0"/>
<Namespace Name="Samples" Create="no" Code="SAMPLES" Data="SAMPLES" Ensemble="0">
<Configuration>
<ClassMapping From="${Namespace}" Package="MDX2JSON"/>
<GlobalMapping From="${Namespace}" Global="MDX2JSON"/>
</Configuration>
</Namespace>

<!--<RunInstall Class="MDX2JSON.Installer" Method="createrole" />-->

<IfDef Var="User" >
<IfDef Var="Password">
<User Username="${User}" Namespace="${Namespace}" PasswordVar="Password" Roles="MDX2JSON" Enabled="true" Comment="MDX2JSON user" Fullname="MDX2JSON user"/>
</IfDef>
<IfNotDef Var="Password">
<Log Text="You specified username but not a password" Level="0"/>
</IfNotDef>
</IfDef>

</Manifest>
}

/// This is a method generator whose code is generated by XGL.
/// Main setup method
/// Set pVars("User")="web"
/// Set pVars("Password")="dsweb"
/// Set pVars("Namespace")="TEMP3"
/// Set pVars("SourceDir")="C:\temp\MDX2JSON\MDX2JSON"
/// Do ##class(MDX2JSON.Installer).setup(.pVars)
ClassMethod setup(ByRef pVars, pLogLevel As %Integer = 0, pInstaller As %Installer.Installer) As %Status [ CodeMode = objectgenerator, Internal ]
{
 	Quit ##class(%Installer.Manifest).%Generate(%compiledclass, %code, "Install")
}

ClassMethod CreateWebApp(pVars, pLogLevel, tInstaller) As %Status
{
	Set Namespace=tInstaller.Evaluate("${Namespace}")
	Do tInstaller.PushNS("%SYS")
	Do ##class(Security.System).GetInstallationSecuritySetting(.security)
	If (security="None") {
		Set cspProperties("AutheEnabled") = $$$AutheUnauthenticated
	} Else {
		Set cspProperties("AutheEnabled") = $$$AutheCache // Password
	}
	Set cspProperties("NameSpace") = Namespace
	Set cspProperties("IsNameSpaceDefault") = $$$YES
	Set cspProperties("DispatchClass") = "MDX2JSON.REST"
	Set tSC = ##class(Security.Applications).Create("/"_Namespace, .cspProperties)
	Do tInstaller.PopNS()
	If $$$ISERR(tSC) Throw ##class(%Installer.Exception).CreateFromStatus(tSC)
	Quit $$$OK
}

ClassMethod DownloadFromGitHub(pVars, pLogLevel, tInstaller) As %Status
{
	Set Namespace=tInstaller.Evaluate("${Namespace}")
	Do tInstaller.PushNS("%SYS")
	Set tSC = ..Update(Namespace, "intersystems-ru", "Cache-MDX2JSON", "master")
	Do tInstaller.PopNS()
	If $$$ISERR(tSC) Throw ##class(%Installer.Exception).CreateFromStatus(tSC)
	quit $$$OK
}

/// Downloads and compiles GitHub repository.<br>
///  <b>Owner</b> - The name of the repository owner.<br>
///  <b>Repository</b> - The name of the repository.<br>
///  <b>Branch</b> - The name of the commit/branch/tag. If skipped the repository’s default branch (usually master) would be used.<br>
///  <b>Username</b> - GitHub user, who has access to repository. Optional for public repositories.<br>
///  <b>Password</b> - GitHub password, corresponding to Username. Optional for public repositories.<br>
///  Note, that with Username, you can make up to 5,000 requests per hour.
///  For unauthenticated requests, the rate limit allows to make up to 60 requests per hour.
///  Unauthenticated requests are associated with an IP address.<br>
///  <b>Namespace</b> - Namespace, where to download and compile repository.<br>
/// 
///  For example in the repository: https://github.com/intersystems-ru/Cache-MDX2JSON<br>
///  Owner - intersystems-ru, Repository - Cache-MDX2JSON.<br> 
ClassMethod Update(Namespace = {$Namespace}, Owner As %String = "intersystems-ru", Repository As %String = "Cache-MDX2JSON", Branch As %String, Username As %String, Password As %String) As %Status
{
	Set namespace = $Namespace
 	Set SSLConfig = "GitHub"

 	Zn "%SYS"
 	Do:'##class(Security.SSLConfigs).Exists(SSLConfig) ##class(Security.SSLConfigs).Create(SSLConfig)

 	Set req=##class(%Net.HttpRequest).%New()
 	Set req.Https=1
	Set req.SSLConfiguration=SSLConfig
	Set req.Server="api.github.com"
	Set req.Location = "repos/" _ Owner _ "/" _ Repository _ "/contents" 	// as described in https://developer.github.com/v3/repos/
	Do:$d(Branch) req.SetParam("ref",Branch) 								// if omitted the repository’s default branch (usually master) would be used
	Do req.SetHeader("Accept","application/vnd.github.v3+json") 			// we want to receive API v3

	If ($d(Username) && $d(Password)) {										// supply Username and Passwor, if both are provided. GitHub accept Basic Auth
		Set req.Username = Username											// https://developer.github.com/v3/auth/
	 	Set req.Password = Password
	}

 	Set links = ##class(%ListOfDataTypes).%New()
 	Set st = ..ProcessDirectory("",req,.links)
 	Return:$$$ISERR(st) st
 	
 	Zn Namespace
	Set st = ..DownloadFiles(links,req,.list)
	Set st2 = $system.OBJ.CompileList(.list)
	Zn namespace

 	Return $$$ADDSC(st, st2)
}

/// Process one directory of GitHub repository. Recursive.<br>
/// <b>Path</b> -Internal repository path. Root is empty string<br>
/// <b>Request</b> - Authenticated/Set %Net.HttpRequest object.<br>
/// <b>Links</b> - List of links to raw files (which satisfy <b>IsCacheFile</b> conditions) from repository.<br>
ClassMethod ProcessDirectory(Path As %String = "", Request As %Net.HttpRequest, ByRef Links As %ListOfDataTypes) As %Status
{
	Set location = Request.Location
	Set Request.Location = Request.Location _ Path

	Set st = Request.Get()
	Return:$$$ISERR(st) st
	Return:(Request.HttpResponse.StatusCode = 404) $$$ERROR($$$GeneralError,"Repository doesn't exist OR you don't have access")
	Return:((Request.HttpResponse.StatusCode = 403) && (Request.HttpResponse.GetHeader("X-RATELIMIT-REMAINING")=0)) $$$ERROR($$$GeneralError,"API rate limit exceeded. Try logging in.")
 	Return:(Request.HttpResponse.StatusCode '= 200) $$$ERROR($$$GeneralError,"Received " _ Request.HttpResponse.StatusCode _ " status, expected 200")

 	#dim objects As List of %ZEN.proxyObject
 	#dim obj As %ZEN.proxyObject
	Set st = ##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(Request.HttpResponse.Data,,.objects,1)
	Return:$$$ISERR(st) st

	For i = 1:1:objects.Count() {
		Set obj = objects.GetAt(i)
		If (obj.type = "dir") {
			Set st = ..ProcessDirectory("/"_obj.name,Request,.Links)
			Return:$$$ISERR(st) st
		} ElseIf (obj.type = "file") {
			Do:..IsCacheFile(obj) Links.Insert(obj."download_url")
		} Else {
			// obj.type = "symlink" or obj.type = "submodule"
		}
	}
	Set Request.Location = location // to keep track of where in the repository tree we are
	Return $$$OK
}

/// Check that incoming file is the one you need.
ClassMethod IsCacheFile(File As %ZEN.proxyObject) As %Boolean
{
	Set extensions = ",xml,cls,csp,csr,mac,int,bas,inc,gbl,prj,obj,pkg,gof,"
	Return:($L(File.name,".")=1) 0 //no extension
	Set File.Extension = $P(File.name,".",$L(File.name,"."))
	Return $F(extensions,","_$ZCVT(File.Extension,"l")_",")
}

/// Download list of files on https://raw.githubusercontent.com/ server.<br>
/// <b>Links</b> - List of links to raw files.<br>
/// <b>Request</b> - Authenticated/Set %Net.HttpRequest object.<br>
/// <b>loadedlist</b> - Returns an array of the items loaded. 
ClassMethod DownloadFiles(Links As %ListOfDataTypes, Request As %Net.HttpRequest, Output Items) As %Status
{
	Kill Items
	Set Request.Server = "raw.githubusercontent.com"
	Set st = $$$OK

	For i = 1:1:Links.Count() {
		Set streq = Request.Get($e(Links.GetAt(i),35,*)) // Remove "https://raw.githubusercontent.com/" from URL.
		Set:$$$ISERR(streq) st=$$$ADDSC(st, streq)
		Set binarystream = Request.HttpResponse.Data
		Do binarystream.Rewind() // just in case

		Set stream=##class(%GlobalCharacterStream).%New() //translating binary stream into character stream
		While 'binarystream.AtEnd {
			Do stream.Write(binarystream.Read())
		}
		Do stream.Rewind()

		Set stload = $system.OBJ.LoadStream(stream,"",.error,.items,,,,"UTF8")
		Set:$$$ISERR(stload) st=$$$ADDSC(st, stload)
		Merge Items = items  // Does not overwrite existing array keys: Items(itemname)=""
	}

	Set Request.Server="api.github.com"
	Return st
}

/// Wrapper method. Uninstalls MDX2JSON (deletes MDX2JSON and %All namespaces, DBs, web apps)
ClassMethod Uninstall(NamespaceList = "%All,MDX2JSON")
{
	For i=1:1:$L(NamespaceList,",") {
		Set Namespace = $P(NamespaceList,",",i)
		Write "Start deleting " _ Namespace,!
		Write $System.Status.GetErrorText(..DeleteNamespace(Namespace))
		Write "End deleting " _ Namespace,!
		Write "Start deleting roles",!
		Write $System.Status.GetErrorText(..DeleteAccess("%DB_MDX2JSON"))
		Write "End deleting roles"
	}
}

/// Delete <var>Role</var> (and resource)
ClassMethod DeleteAccess(Role = "%DB_MDX2JSON") As %Status
{
	New $Namespace
	Set $Namespace = "%SYS"
	Set st = $$$OK
	Set st = ##class(Security.Resources).Delete(Role)
	Set st = $$$ADDSC(st, ##class(Security.Roles).Delete(Role))
	Return st
}

/// Delete <var>Namespace</var>, related web apps and databases
ClassMethod DeleteNamespace(Namespace = {$Namespace}) As %Status
{
	// Based on %CSP.UI.Portal.Dialog.NamespaceDelete:SaveData and 
	// %CSP.UI.Portal.Dialog.DatabaseDelete:Delete
	Try {
		New $Namespace
		Set $Namespace = "%SYS"
		Set st = $$$OK
		If ##Class(Config.Namespaces).Exists(Namespace,.NamespaceObj) {
			// Get databases names
			Set Routines = NamespaceObj.Routines
			Set Globals = NamespaceObj.Globals
			Kill NamespaceObj
			
			// Remove Ensemble namespace
		 	If ((##class(%Library.EnsembleMgr).IsEnsembleInstalled() || ##class(%Library.EnsembleMgr).IsHealthShareInstalled())) {
		 		Set st1 = ##class(%Library.EnsembleMgr).DisableNamespace(Namespace)
		 		Set st = $$$ADDSC(st, st1)
		 	}
		
			Set st1 = ..DeleteWebApps(Namespace)
			Set st = $$$ADDSC(st, st1)
			Set st1 = ..DeletePackageMappings("", Routines)
			Set st = $$$ADDSC(st, st1)
			Set st1 = ..DeleteGlobalMappings("", Globals)
			Set st = $$$ADDSC(st, st1)
			
			Set st1 = ##class(Config.Namespaces).Delete(Namespace)
			Set st = $$$ADDSC(st, st1)
			
			Set st1 = ..DeleteDatabase(Routines)
			Set st = $$$ADDSC(st, st1)
			
			If Globals'=Routines {
				Set st1 = ..DeleteDatabase(Globals)
				Set st = $$$ADDSC(st, st1)
			}
		} Else {
			Set st = $$$ERROR($$$GeneralError, "Namespace " _ Namespace _ " does not exist")
		}
	} Catch ex {
		Set st =  $$$ADDSC(st, ex.AsStatus())
	}
	Return st
}

/// Delete all webapps in a <var>Namespace</var>, also dele
ClassMethod DeleteDatabase(Database As %String = "MDX2JSON") As %Status
{
	New $Namespace
	Set $Namespace = "%SYS"
	Set st = $$$OK
	Try {
		If ##Class(Config.Databases).Get(Database,.Properties) {
  			Set Directory = $G(Properties("Directory"))
  			Set st1 = ##class(SYS.Database).DismountDatabase(Directory)
  			Set st = $$$ADDSC(st, st1)
			Set st1 = ##class(Config.Databases).Delete(Database)
			Set st = $$$ADDSC(st, st1)
			Set st1 = ##class(SYS.Database).DeleteDatabase(Directory)
			Set st = $$$ADDSC(st, st1)
			Do ##class(%File).RemoveDirectoryTree(Directory)
			Set st = $$$ADDSC(st, %objlasterror)
		} Else {
			Set st = $$$ERROR($$$GeneralError, "Database " _ Database _ " does not exist")
		}
	} Catch(ex) {
		Set st = $$$ADDSC(st ,ex.AsStatus())
	}
	Return st
}

/// Delete all webapps in a <var>Namespace</var>, also dele
ClassMethod DeleteWebApps(Namespace As %String = "MDX2JSON", ClearPath As %Boolean = 0) As %Status
{
	New $Namespace
	Set $Namespace = "%SYS"
	Set st = $$$OK
	Try {
		#Dim rs  As %SQL.StatementResult 
		Set rs = ##class(%SQL.Statement).%ExecDirect(,"SELECT Name, Path FROM Security.Applications WHERE NameSpace = ?", Namespace)
		While rs.%Next() {
			Set st1 = ##class(Security.Applications).Delete(rs.Name)
			Set st = $$$ADDSC(st, st1)
			If ((ClearPath) && (rs.Path'="")) {
				Do ##class(%File).RemoveDirectoryTree(rs.Path)
				Set st = $$$ADDSC(st, %objlasterror)
			}
		}
	} Catch(ex) {
		Set st = $$$ADDSC(st, ex.AsStatus())
	}
	Return st
}

/// Delete all mappings of <var>Package</var> in <var>Database</var> from all Namespaces
ClassMethod DeletePackageMappings(Package As %String = "", Database As %String = "MDX2JSON") As %Status
{
	New $Namespace
	Set $Namespace = "%SYS"
	Set st = $$$OK
	Try {
		#Dim rs  As %SQL.StatementResult 
		Set rs = ##class(%SQL.Statement).%ExecDirect(,"SELECT Namespace FROM Config.MapPackages WHERE Name %STARTSWITH ? AND Database = ?", Package, Database)
		While rs.%Next() {
			Set st1 = ##Class(Config.MapPackages).Delete(rs.%Get("Namespace"), Database)
			Set st = $$$ADDSC(st, st1)
			Set st1 = ..ActivateConfiguration(rs.Namespace)
			Set st = $$$ADDSC(st, st1)
		}
	} Catch(ex) {
		Set st = $$$ADDSC(st, ex.AsStatus())
	}
	Return st
}

/// Delete all mappings of <var>Global</var> in <var>Database</var> from all Namespaces
ClassMethod DeleteGlobalMappings(Global As %String = "", Database As %String = "MDX2JSON") As %Status
{
	New $Namespace
	Set $Namespace = "%SYS"
	Set st = $$$OK
	Try {
		#Dim rs  As %SQL.StatementResult 
		Set rs = ##class(%SQL.Statement).%ExecDirect(,"SELECT Namespace FROM Config.MapGlobals WHERE Name %STARTSWITH ? AND Database = ?", Global, Database)
		While rs.%Next() {
			Set st1 = ##Class(Config.MapGlobals).Delete(rs.Namespace, Database)
			Set st = $$$ADDSC(st, st1)
			Set st1 = ..ActivateConfiguration(rs.Namespace)
			Set st = $$$ADDSC(st, st1)
		}
	} Catch(ex) {
		Set st = $$$ADDSC(st, ex.AsStatus())
	}
	Return st
}

/// Activate a configuration in a <var>Namespace</var>
ClassMethod ActivateConfiguration(Namespace As %String) As %Status
{
	Set st = $$$OK
	Set Namespace=$ZCVT(Namespace,"U")
	
	Set st = ##Class(Config.CPF).Write()
	Return:$$$ISERR(st) st
	Set st = ##Class(Config.Map).MoveToActive(Namespace)
	Return:$$$ISERR(st) st
 	Set st = ##Class(Config.Namespaces).Load(Namespace)
	Return st
}

}

